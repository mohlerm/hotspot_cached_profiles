--- old/src/share/vm/c1/c1_Compilation.cpp	2016-08-15 12:26:06.989019658 +0200
+++ new/src/share/vm/c1/c1_Compilation.cpp	2016-08-15 12:26:06.861019658 +0200
@@ -583,6 +583,22 @@
       md->set_would_profile(_would_profile);
     }
   }
+  // Dump profile to allow profile caching
+  if(_env->comp_level()>CompLevel_limited_profile && _env->comp_level() >= DumpProfilesMinTier) {
+    if ((DumpProfiles || _method->has_option("DumpProfile")) && (!_method->has_option("IgnoreDumpProfile"))) {
+		const char* klassmethod = _method->holder()->name()->as_utf8();
+		int length = strlen(klassmethod);
+		char* subbuff = NEW_RESOURCE_ARRAY(char,length+1);
+		memcpy( subbuff, klassmethod, length );
+		subbuff[length] = '\0';
+		if(strncmp(subbuff,"jdk/nashorn/internal/scripts/Script$Recompilation", 49)==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$MH")==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$BMH")==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$DMH")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/ScriptObject")==0 || strcmp(subbuff,"jdk/internal/org/objectweb/asm/ClassWriter")==0 || strncmp(subbuff,"java/util/stream/ReferencePipeline", 34)==0 || strcmp(subbuff,"jdk/internal/loader/BuiltinClassLoader")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/types/Type")==0 || strcmp(subbuff,"java/util/concurrent/ConcurrentHashMap")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/CompilerConstants")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/MethodEmitter")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/TypeEvaluator")==0 || strcmp(subbuff, "jdk/dynalink/TypeConverterFactory")==0 || strcmp(subbuff, "java/lang/invoke/BoundMethodHandle")==0 || strcmp(subbuff, "java/lang/invoke/MethodHandleImpl")==0 || strcmp(subbuff, "jdk/nashorn/internal/codegen/types/ArrayType")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/ClassEmitter")==0 || strcmp(subbuff,"jdk/dynalink/LinkerServicesImpl")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/linker/NashornLinker")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/AccessorProperty")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/CodeGenerator")==0 || strcmp(subbuff,"java/security/Permissions")==0 || strcmp(subbuff," jdk/nashorn/internal/runtime/linker/NashornGuards")==0) {
+			//tty->print("###Avoided: %s\n",method()->holder()->name()->as_utf8());
+		} else {
+			//tty->print("###Dump: %s\n",method()->holder()->name()->as_utf8());
+			_env->dump_cache_profiles(0, _method->name()->as_utf8());
+		}
+    }
+  }
 }
 
 Compilation::~Compilation() {
--- old/src/share/vm/ci/ciClassList.hpp	2016-08-15 12:26:07.705019658 +0200
+++ new/src/share/vm/ci/ciClassList.hpp	2016-08-15 12:26:07.525019658 +0200
@@ -109,6 +109,8 @@
 friend class ciObjArray;               \
 friend class ciMetadata;               \
 friend class ciReplay;                 \
+friend class ciCacheProfiles;          \
+friend class ciCacheReplay;            \
 friend class ciTypeArray;              \
 friend class ciType;                   \
 friend class ciReturnAddress;          \
--- old/src/share/vm/ci/ciEnv.cpp	2016-08-15 12:26:08.153019658 +0200
+++ new/src/share/vm/ci/ciEnv.cpp	2016-08-15 12:26:08.013019658 +0200
@@ -31,6 +31,7 @@
 #include "ci/ciMethod.hpp"
 #include "ci/ciNullObject.hpp"
 #include "ci/ciReplay.hpp"
+#include "ci/ciCacheReplay.hpp"
 #include "ci/ciUtilities.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
@@ -1244,7 +1245,7 @@
 
 void ciEnv::dump_replay_data(int compile_id) {
   static char buffer[O_BUFLEN];
-  int ret = jio_snprintf(buffer, O_BUFLEN, "replay_pid%p_compid%d.log", os::current_process_id(), compile_id);
+  int ret = jio_snprintf(buffer, O_BUFLEN, "replay_pid%d_compid%d.log", os::current_process_id(), compile_id);
   if (ret > 0) {
     int fd = open(buffer, O_RDWR | O_CREAT | O_TRUNC, 0666);
     if (fd != -1) {
@@ -1260,9 +1261,10 @@
   }
 }
 
+
 void ciEnv::dump_inline_data(int compile_id) {
   static char buffer[O_BUFLEN];
-  int ret = jio_snprintf(buffer, O_BUFLEN, "inline_pid%p_compid%d.log", os::current_process_id(), compile_id);
+  int ret = jio_snprintf(buffer, O_BUFLEN, "inline_pid%d_compid%d.log", os::current_process_id(), compile_id);
   if (ret > 0) {
     int fd = open(buffer, O_RDWR | O_CREAT | O_TRUNC, 0666);
     if (fd != -1) {
@@ -1281,4 +1283,58 @@
       }
     }
   }
+}
+
+void ciEnv::dump_cache_profiles_unsafe(outputStream* out) {
+  ResourceMark rm;
+#if INCLUDE_JVMTI
+  out->print_cr("JvmtiExport can_access_local_variables %d",     _jvmti_can_access_local_variables);
+  out->print_cr("JvmtiExport can_hotswap_or_post_breakpoint %d", _jvmti_can_hotswap_or_post_breakpoint);
+  out->print_cr("JvmtiExport can_post_on_exceptions %d",         _jvmti_can_post_on_exceptions);
+#endif // INCLUDE_JVMTI
+
+  GrowableArray<ciMetadata*>* objects = _factory->get_ci_metadata();
+  out->print_cr("# %d ciObject found", objects->length());
+  for (int i = 0; i < objects->length(); i++) {
+    if(objects->at(i)->is_method() || objects->at(i)->is_method_data()) {
+      objects->at(i)->dump_replay_data(out);
+    }
+  }
+  dump_compile_data(out);
+  out->flush();
+}
+
+void ciEnv::dump_cache_profiles(outputStream* out) {
+  GUARDED_VM_ENTRY(
+    MutexLocker ml(Compile_lock);
+    dump_cache_profiles_unsafe(out);
+  )
+}
+
+bool ciEnv::first_dump = true;
+
+void ciEnv::dump_cache_profiles(int compile_id, const char* methodName) {
+  static char buffer[O_BUFLEN];
+  //int ret = jio_snprintf(buffer, O_BUFLEN, "profiles_pid%d_compid%d.dat", os::current_process_id(), compile_id);
+  //int ret = jio_snprintf(buffer, O_BUFLEN, "cached_profiles_%s.dat", methodName);
+  int ret = jio_snprintf(buffer, O_BUFLEN, "cached_profiles.dat");
+  if (ret > 0) {
+    int fd = -1;
+    if(first_dump) {
+      fd = open(buffer, O_RDWR | O_CREAT | O_TRUNC, 0666);
+      first_dump = false;
+    } else {
+      fd = open(buffer, O_RDWR | O_CREAT | O_APPEND, 0666);
+    }
+    if (fd != -1) {
+      FILE* replay_data_file = os::open(fd, "w");
+      if (replay_data_file != NULL) {
+        fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
+        dump_cache_profiles(&replay_data_stream);
+        if(PrintCacheProfiles) tty->print_cr("# Compiler cached profile is saved as: %s", buffer);
+      } else {
+        if(PrintCacheProfiles) tty->print_cr("# Can't open file to dump cached profile.");
+      }
+    }
+  }
 }
--- old/src/share/vm/ci/ciEnv.hpp	2016-08-15 12:26:08.617019658 +0200
+++ new/src/share/vm/ci/ciEnv.hpp	2016-08-15 12:26:08.473019658 +0200
@@ -459,11 +459,16 @@
   void metadata_do(void f(Metadata*)) { _factory->metadata_do(f); }
 
   // Dump the compilation replay data for the ciEnv to the stream.
+  static bool first_dump;
   void dump_replay_data(int compile_id);
   void dump_inline_data(int compile_id);
   void dump_replay_data(outputStream* out);
   void dump_replay_data_unsafe(outputStream* out);
   void dump_compile_data(outputStream* out);
+  // Dump the cached profiling information for the ciEnv to the stream.
+  void dump_cache_profiles(int compile_id, const char* methodName);
+  void dump_cache_profiles(outputStream* out);
+  void dump_cache_profiles_unsafe(outputStream* out);
 };
 
 #endif // SHARE_VM_CI_CIENV_HPP
--- old/src/share/vm/ci/ciMethod.cpp	2016-08-15 12:26:09.341019658 +0200
+++ new/src/share/vm/ci/ciMethod.cpp	2016-08-15 12:26:09.153019658 +0200
@@ -32,6 +32,7 @@
 #include "ci/ciStreams.hpp"
 #include "ci/ciSymbol.hpp"
 #include "ci/ciReplay.hpp"
+#include "ci/ciCacheReplay.hpp"
 #include "ci/ciUtilities.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "compiler/abstractCompiler.hpp"
@@ -154,6 +155,9 @@
     ciReplay::initialize(this);
   }
 #endif
+  if (CacheProfiles) {
+    ciCacheReplay::initialize(this);
+  }
 }
 
 
--- old/src/share/vm/ci/ciMethod.hpp	2016-08-15 12:26:10.129019658 +0200
+++ new/src/share/vm/ci/ciMethod.hpp	2016-08-15 12:26:09.893019658 +0200
@@ -53,6 +53,7 @@
   friend class ciBytecodeStream;
   friend class ciMethodHandle;
   friend class ciReplay;
+  friend class ciCacheReplay;
   friend class InlineTree;
 
  private:
--- old/src/share/vm/ci/ciMethodData.cpp	2016-08-15 12:26:10.805019658 +0200
+++ new/src/share/vm/ci/ciMethodData.cpp	2016-08-15 12:26:10.597019658 +0200
@@ -26,6 +26,7 @@
 #include "ci/ciMetadata.hpp"
 #include "ci/ciMethodData.hpp"
 #include "ci/ciReplay.hpp"
+#include "ci/ciCacheReplay.hpp"
 #include "ci/ciUtilities.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
@@ -182,6 +183,9 @@
     ciReplay::initialize(this);
   }
 #endif
+  if (CacheProfiles) {
+    ciCacheReplay::initialize(this);
+  }
 }
 
 void ciReceiverTypeData::translate_receiver_data_from(const ProfileData* data) {
--- old/src/share/vm/ci/ciMethodData.hpp	2016-08-15 12:26:11.565019658 +0200
+++ new/src/share/vm/ci/ciMethodData.hpp	2016-08-15 12:26:11.353019658 +0200
@@ -370,6 +370,7 @@
 class ciMethodData : public ciMetadata {
   CI_PACKAGE_ACCESS
   friend class ciReplay;
+  friend class ciCacheReplay;
 
 private:
   // Size in bytes
--- old/src/share/vm/compiler/compileBroker.cpp	2016-08-15 12:26:12.177019658 +0200
+++ new/src/share/vm/compiler/compileBroker.cpp	2016-08-15 12:26:11.965019658 +0200
@@ -25,6 +25,7 @@
 #include "precompiled.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
+#include "ci/ciCacheProfiles.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/codeCache.hpp"
 #include "code/dependencyContext.hpp"
@@ -306,6 +307,9 @@
   if (CIPrintCompileQueue) {
     print_tty();
   }
+  if (PrintCompileQueueSize) {
+    tty->print_cr("%d - Size of %s: %d", (int) tty->time_stamp().milliseconds(), name(),_size);
+  }
 
   if (LogCompilation && xtty != NULL) {
     task->log_task_queued();
@@ -393,6 +397,7 @@
 
   remove(task);
   purge_stale_tasks(); // may temporarily release MCQ lock
+
   return task;
 }
 
@@ -1034,11 +1039,11 @@
   }
 }
 
-
 nmethod* CompileBroker::compile_method(const methodHandle& method, int osr_bci,
                                        int comp_level,
                                        const methodHandle& hot_method, int hot_count,
                                        const char* comment, Thread* THREAD) {
+
   // make sure arguments make sense
   assert(method->method_holder()->is_instance_klass(), "not an instance method");
   assert(osr_bci == InvocationEntryBci || (0 <= osr_bci && osr_bci < method->code_size()), "bci out of range");
@@ -1048,6 +1053,48 @@
   assert(WhiteBoxAPI || TieredCompilation || comp_level == CompLevel_highest_tier, "only CompLevel_highest_tier must be used in non-tiered");
   // return quickly if possible
 
+ // start by figuring out the new compile level in case the method is cached
+ int cached_comp_level = 0;
+ if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+   // if it's set trigger replayCompilation in case it's a cached method
+   cached_comp_level = ciCacheProfiles::is_cached(method());
+   // we only use cached profiles for Level 3 or 4
+   // because 1 and 2 are used in special cases (i.e. compile queue full)
+   // and we don't want to mess with that
+   // also check if decompile count is less than 10 since we don't want to
+   // recompile a lot using a bad profile
+   if(cached_comp_level > CompLevel_limited_profile && comp_level > CompLevel_limited_profile
+	   && (method->method_data() == NULL || (method->method_data() != NULL && method->method_data()->decompile_count() < 10)))
+   {
+	 // now both compile level and cache level are always >= 3
+	 //
+	 // if we're in cacheprofilemode 2 AND compile level 3 and have a cache level 4
+	 // always set compile level to 2 to remove profiling from C1
+	 if(CacheProfilesMode==2 && (comp_level == CompLevel_full_profile && cached_comp_level == CompLevel_full_optimization)) {
+	   comp_level = CompLevel_limited_profile;
+	   if(PrintCacheProfiles) {
+		 tty->print("CacheProfiles: Force Compilationlevel to %d, Hotcount: %d, OSR_BCI: %d :: ", comp_level,hot_count,osr_bci);
+		 method->print_name(tty);
+		 tty->print_cr(" <");
+	   }
+	 // as long as we're not in mode 2
+	 // OR in mode 2 and a level 3 (with no level 4 profile available) or level 4 compilation (with either profiles)
+	 } else {
+	   // fix compile level to the one of the cached profile
+	   // this can result in promotion of level 3 compilations to level 4
+	   // (not the other way around)
+	   if(comp_level < cached_comp_level) {
+		 if(PrintCacheProfiles) {
+		   tty->print("CacheProfiles: Promote Compilationlevel from %d to %d, Hotcount: %d, OSR_BCI: %d :: ",comp_level, cached_comp_level, hot_count,osr_bci);
+		   method->print_name(tty);
+		   tty->print_cr(" <");
+		 }
+		 comp_level = cached_comp_level;
+	   }
+	 }
+   }
+ }
+
   // lock, make sure that the compilation
   // isn't prohibited in a straightforward way.
   AbstractCompiler *comp = CompileBroker::compiler(comp_level);
@@ -1160,6 +1207,34 @@
       CompilationPolicy::policy()->delay_compilation(method());
       return NULL;
     }
+ // first, check whether the CacheProfiles flag is set, if not continue as usual
+ if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+   // if it's set trigger replayCompilation in case it's a cached method
+   // continue if method is cached and of level 3 or 4
+   // AND our compile level actually matches cache level (we can not use a LVL3 profile for LVL4 compilations)
+   // AND finally check if method has not been compiled more than 10 time already (using the cached profile)
+   // Note: this is independent of the cacheprofilesmode since it will lower the level to 2 if it
+   //       does not want to use cached profiles
+   if(cached_comp_level > CompLevel_limited_profile &&  comp_level > CompLevel_limited_profile
+	   && comp_level == cached_comp_level
+	   && (method->method_data() == NULL || (method->method_data() != NULL && method->method_data()->decompile_count() < 10)))
+   {
+	 if(PrintCacheProfiles) {
+	   tty->print("CacheProfiles: Use level %d profile for level %d compilation, Hotcount: %d, OSR_BCI: %d :: ",cached_comp_level, comp_level, hot_count,osr_bci);
+	   method->print_name(tty);
+	   tty->print_cr(" <");
+	 }
+	 ciCacheProfiles::replay(THREAD,method(),osr_bci,false);
+	 return osr_bci  == InvocationEntryBci ? method->code() : method->lookup_osr_nmethod_for(osr_bci, comp_level, false);
+   }
+ }
+ // if it's not in the cache or if we're using CacheProfileMode=2, just compile method base
+ if(PrintCacheProfiles) {
+   //tty->print("CacheProfiles: Not use profile for level %d compilation, Hotcount: %d, OSR_BCI: %d :: ",comp_level, hot_count,osr_bci);
+   //method->print_name(tty);
+   //tty->print_cr(" <");
+ }
+    //bool is_blocking = !directive->BackgroundCompilationOption || CompileTheWorld || ReplayCompiles;
     compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, comment, THREAD);
   }
 
@@ -1313,7 +1388,6 @@
   return !BackgroundCompilation;
 }
 
-
 // ------------------------------------------------------------------
 // CompileBroker::preload_classes
 void CompileBroker::preload_classes(const methodHandle& method, TRAPS) {
--- old/src/share/vm/compiler/compileBroker.hpp	2016-08-15 12:26:12.837019658 +0200
+++ new/src/share/vm/compiler/compileBroker.hpp	2016-08-15 12:26:12.693019658 +0200
@@ -140,6 +140,7 @@
 class CompileBroker: AllStatic {
  friend class Threads;
  friend class CompileTaskWrapper;
+ friend class CacheCompileReplay;
 
  public:
   enum {
--- old/src/share/vm/interpreter/invocationCounter.hpp	2016-08-15 12:26:13.589019658 +0200
+++ new/src/share/vm/interpreter/invocationCounter.hpp	2016-08-15 12:26:13.381019658 +0200
@@ -41,6 +41,7 @@
 class InvocationCounter VALUE_OBJ_CLASS_SPEC {
   friend class VMStructs;
   friend class ciReplay;
+  friend class ciCacheReplay;
  private:                             // bit no: |31  3|  2  | 1 0 |
   unsigned int _counter;              // format: [count|carry|state]
 
--- old/src/share/vm/oops/instanceKlass.hpp	2016-08-15 12:26:14.313019658 +0200
+++ new/src/share/vm/oops/instanceKlass.hpp	2016-08-15 12:26:14.125019658 +0200
@@ -113,6 +113,7 @@
   friend class JVMCIVMStructs;
   friend class ClassFileParser;
   friend class CompileReplay;
+  friend class CacheCompileReplay;
 
  protected:
   InstanceKlass(const ClassFileParser& parser, unsigned kind);
--- old/src/share/vm/oops/klass.hpp	2016-08-15 12:26:15.009019658 +0200
+++ new/src/share/vm/oops/klass.hpp	2016-08-15 12:26:14.813019658 +0200
@@ -304,10 +304,11 @@
     _lh_header_size_mask        = right_n_bits(BitsPerByte),  // shifted mask
     _lh_array_tag_bits          = 2,
     _lh_array_tag_shift         = BitsPerInt - _lh_array_tag_bits,
-    _lh_array_tag_type_value    = ~0x00,  // 0xC0000000 >> 30
     _lh_array_tag_obj_value     = ~0x01   // 0x80000000 >> 30
   };
 
+  static const unsigned int _lh_array_tag_type_value = 0Xffffffff; // ~0x00,  // 0xC0000000 >> 30
+
   static int layout_helper_size_in_bytes(jint lh) {
     assert(lh > (jint)_lh_neutral_value, "must be instance");
     return (int) lh & ~_lh_instance_slow_path_bit;
--- old/src/share/vm/oops/methodCounters.cpp	2016-08-15 12:26:15.777019658 +0200
+++ new/src/share/vm/oops/methodCounters.cpp	2016-08-15 12:26:15.597019658 +0200
@@ -24,6 +24,7 @@
 #include "precompiled.hpp"
 #include "oops/methodCounters.hpp"
 #include "runtime/handles.inline.hpp"
+#include "ci/ciCacheProfiles.hpp"
 
 MethodCounters* MethodCounters::allocate(methodHandle mh, TRAPS) {
   ClassLoaderData* loader_data = mh->method_holder()->class_loader_data();
@@ -45,6 +46,18 @@
 }
 
 
+bool MethodCounters::scale_if_cached(methodHandle mh, double& scale) {
+   // in case the CacheProfile functionality is used:
+   // in mode0, check if method is cached and lower threshold automatically
+    if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+      if(CacheProfilesMode==0 && ciCacheProfiles::is_cached(mh)) {
+        scale = CacheProfilesMode0ThresholdScaling;
+        return true;
+      }
+    }
+    return false;
+}
+
 int MethodCounters::highest_comp_level() const {
 #ifdef TIERED
   return _highest_comp_level;
@@ -72,4 +85,3 @@
   _highest_osr_comp_level = level;
 #endif
 }
-
--- old/src/share/vm/oops/methodCounters.hpp	2016-08-15 12:26:16.217019658 +0200
+++ new/src/share/vm/oops/methodCounters.hpp	2016-08-15 12:26:16.093019658 +0200
@@ -80,6 +80,8 @@
 
     // Set per-method thresholds.
     double scale = 1.0;
+
+    scale_if_cached(mh, scale);
     CompilerOracle::has_option_value(mh, "CompileThresholdScaling", scale);
 
     int compile_threshold = Arguments::scaled_compile_threshold(CompileThreshold, scale);
@@ -143,6 +145,8 @@
   void set_rate(float rate)                      { _rate = rate; }
 #endif
 
+  bool scale_if_cached(methodHandle mh, double& scale );
+
   int highest_comp_level() const;
   void set_highest_comp_level(int level);
   int highest_osr_comp_level() const;
--- old/src/share/vm/oops/methodData.cpp	2016-08-15 12:26:16.821019658 +0200
+++ new/src/share/vm/oops/methodData.cpp	2016-08-15 12:26:16.665019658 +0200
@@ -37,6 +37,7 @@
 #include "runtime/handles.inline.hpp"
 #include "runtime/orderAccess.inline.hpp"
 #include "utilities/copy.hpp"
+#include "ci/ciCacheProfiles.hpp"
 
 // ==================================================================
 // DataLayout
@@ -1216,6 +1217,14 @@
 
   // Set per-method invoke- and backedge mask.
   double scale = 1.0;
+
+  if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+    // in case the CacheProfile functionality is used:
+    // in mode0, check if method is cached and lower threshold automatically
+    if(CacheProfilesMode==0 && ciCacheProfiles::is_cached(_method)) {
+      scale = CacheProfilesMode0ThresholdScaling;
+    }
+  }
   CompilerOracle::has_option_value(_method, "CompileThresholdScaling", scale);
   _invoke_mask = right_n_bits(Arguments::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;
   _backedge_mask = right_n_bits(Arguments::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;
--- old/src/share/vm/opto/bytecodeInfo.cpp	2016-08-15 12:26:17.321019658 +0200
+++ new/src/share/vm/opto/bytecodeInfo.cpp	2016-08-15 12:26:17.197019658 +0200
@@ -24,6 +24,8 @@
 
 #include "precompiled.hpp"
 #include "ci/ciReplay.hpp"
+#include "ci/ciCacheReplay.hpp"
+#include "ci/ciCacheProfiles.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "compiler/compileBroker.hpp"
@@ -124,9 +126,13 @@
       _forced_inline = true;
       return true;
   }
-
-#ifndef PRODUCT
   int inline_depth = inline_level()+1;
+  if (ciCacheReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {
+    set_msg("force inline by ciCacheReplay");
+    _forced_inline = true;
+    return true;
+  }
+#ifndef PRODUCT
   if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {
     set_msg("force inline by ciReplay");
     _forced_inline = true;
@@ -176,6 +182,12 @@
     // Not hot.  Check for medium-sized pre-existing nmethod at cold sites.
     if (callee_method->has_compiled_code() &&
         callee_method->instructions_size() > inline_small_code_size) {
+	  // we force inlining when the caller is cached (to make sure that we replay correctly)
+	  if (ciCacheProfiles::is_cached(caller_method->get_Method())) {
+		set_msg("force inline by ciCacheProfiles (over compiled into medium method)");
+		_forced_inline = true;
+		return true;
+	  }
       set_msg("already compiled into a medium method");
       return false;
     }
@@ -231,10 +243,23 @@
     set_msg("disallowed by CompileCommand");
     return true;
   }
-
-#ifndef PRODUCT
   int caller_bci = jvms->bci();
   int inline_depth = inline_level()+1;
+  if (ciCacheReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {
+    set_msg("force inline by ciCacheReplay");
+    return false;
+  }
+
+  if (ciCacheReplay::should_not_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {
+    set_msg("disallowed by ciCacheReplay");
+    return true;
+  }
+
+  if (ciCacheReplay::should_not_inline(callee_method)) {
+    set_msg("disallowed by ciCacheReplay");
+    return true;
+  }
+#ifndef PRODUCT
   if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {
     set_msg("force inline by ciReplay");
     return false;
--- old/src/share/vm/opto/compile.cpp	2016-08-15 12:26:17.733019658 +0200
+++ new/src/share/vm/opto/compile.cpp	2016-08-15 12:26:17.609019658 +0200
@@ -26,6 +26,8 @@
 #include "asm/macroAssembler.hpp"
 #include "asm/macroAssembler.inline.hpp"
 #include "ci/ciReplay.hpp"
+#include "ci/ciCacheReplay.hpp"
+#include "ci/ciCacheProfiles.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "code/exceptionHandlerTable.hpp"
 #include "code/nmethod.hpp"
@@ -876,6 +878,22 @@
   if (directive->DumpInlineOption && (ilt() != NULL)) {
     env()->dump_inline_data(_compile_id);
   }
+  // Dump profile to allow profile caching
+  if(env()->comp_level()>CompLevel_limited_profile && env()->comp_level() >= DumpProfilesMinTier) {
+    if ((DumpProfiles || method()->has_option("DumpProfile")) && (!method()->has_option("IgnoreDumpProfile"))) {
+		const char* klassmethod = _method->holder()->name()->as_utf8();
+		int length = strlen(klassmethod);
+		char* subbuff = NEW_RESOURCE_ARRAY(char,length+1);
+		memcpy( subbuff, klassmethod, length );
+		subbuff[length] = '\0';
+		if(strncmp(subbuff,"jdk/nashorn/internal/scripts/Script$Recompilation", 49)==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$MH")==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$BMH")==0 || strcmp(subbuff,"java/lang/invoke/LambdaForm$DMH")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/ScriptObject")==0 || strcmp(subbuff,"jdk/internal/org/objectweb/asm/ClassWriter")==0 || strncmp(subbuff,"java/util/stream/ReferencePipeline", 34)==0 || strcmp(subbuff,"jdk/internal/loader/BuiltinClassLoader")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/types/Type")==0 || strcmp(subbuff,"java/util/concurrent/ConcurrentHashMap")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/CompilerConstants")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/MethodEmitter")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/TypeEvaluator")==0 || strcmp(subbuff, "jdk/dynalink/TypeConverterFactory")==0 || strcmp(subbuff, "java/lang/invoke/BoundMethodHandle")==0 || strcmp(subbuff, "java/lang/invoke/MethodHandleImpl")==0 || strcmp(subbuff, "jdk/nashorn/internal/codegen/types/ArrayType")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/ClassEmitter")==0 || strcmp(subbuff,"jdk/dynalink/LinkerServicesImpl")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/linker/NashornLinker")==0 || strcmp(subbuff,"jdk/nashorn/internal/runtime/AccessorProperty")==0 || strcmp(subbuff,"jdk/nashorn/internal/codegen/CodeGenerator")==0 || strcmp(subbuff,"java/security/Permissions")==0 || strcmp(subbuff," jdk/nashorn/internal/runtime/linker/NashornGuards")==0) {
+			//tty->print("###Avoided: %s\n",method()->holder()->name()->as_utf8());
+		} else {
+			//tty->print("###Dump: %s\n",method()->holder()->name()->as_utf8());
+			_env->dump_cache_profiles(0, method()->name()->as_utf8());
+		}
+    }
+  }
 
   // Now that we know the size of all the monitors we can add a fixed slot
   // for the original deopt pc.
@@ -4207,6 +4225,8 @@
 void Compile::dump_inline_data(outputStream* out) {
   InlineTree* inl_tree = ilt();
   if (inl_tree != NULL) {
+    //tty->print(">DUMP_INLINE_DATA FOR:");method()->print_name(tty);tty->print("\n");
+    //tty->print(">INL_TREE->COUNT() = %d<\n",inl_tree->count());
     out->print(" inline %d", inl_tree->count());
     inl_tree->dump_replay_data(out);
   }
--- old/src/share/vm/opto/library_call.cpp	2016-08-15 12:26:18.437019658 +0200
+++ new/src/share/vm/opto/library_call.cpp	2016-08-15 12:26:18.293019658 +0200
@@ -3768,7 +3768,7 @@
   }
   // Now test the correct condition.
   jint  nval = (obj_array
-                ? ((jint)Klass::_lh_array_tag_type_value
+                ? (jint)(Klass::_lh_array_tag_type_value
                    <<    Klass::_lh_array_tag_shift)
                 : Klass::_lh_neutral_value);
   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
--- old/src/share/vm/prims/jvmtiExport.hpp	2016-08-15 12:26:19.009019658 +0200
+++ new/src/share/vm/prims/jvmtiExport.hpp	2016-08-15 12:26:18.873019658 +0200
@@ -66,6 +66,7 @@
 class JvmtiExport : public AllStatic {
   friend class VMStructs;
   friend class CompileReplay;
+  friend class CacheCompileReplay;
 
  private:
 
--- old/src/share/vm/runtime/advancedThresholdPolicy.cpp	2016-08-15 12:26:19.493019658 +0200
+++ new/src/share/vm/runtime/advancedThresholdPolicy.cpp	2016-08-15 12:26:19.337019658 +0200
@@ -408,6 +408,11 @@
       if (is_method_profiled(method)) {
         // Special case: we got here because this method was fully profiled in the interpreter.
         next_level = CompLevel_full_optimization;
+      } else if (CacheProfiles && CacheProfilesMode==2 && ciCacheProfiles::is_initialized() && ciCacheProfiles::is_cached(method)==CompLevel_full_optimization) {
+        // another Special case: we run in CacheProfilesMode=2 meaning all methods that are cached
+        // (with full optimizations) and want to be compiled with full profiles get degraded to
+        // limited profiles therefore we need a new transition from limited profiles to full optimization.
+        next_level = CompLevel_full_optimization;
       } else {
         MethodData* mdo = method->method_data();
         if (mdo != NULL) {
--- old/src/share/vm/runtime/deoptimization.cpp	2016-08-15 12:26:19.997019658 +0200
+++ new/src/share/vm/runtime/deoptimization.cpp	2016-08-15 12:26:19.805019658 +0200
@@ -774,6 +774,10 @@
   return bt;
 JRT_END
 
+void Deoptimization::print_deoptimization_count() {
+  ttyLocker ttyl;
+  tty->print_cr("Total number of deoptimizations: %d <<<", _deoptimization_count);
+}
 
 int Deoptimization::deoptimize_dependents() {
   Threads::deoptimized_wrt_marked_nmethods();
@@ -1150,6 +1154,12 @@
     }
   }
 #endif
+  if (PrintDeoptimizationCount || PrintDeoptimizationCountVerbose) {
+    increase_deoptimization_count();
+    if (PrintDeoptimizationCountVerbose) {
+      print_deoptimization_count();
+    }
+  }
 
   // Register map for next frame (used for stack crawl).  We capture
   // the state of the deopt'ing frame's caller.  Thus if we need to
@@ -1285,6 +1295,11 @@
   BiasedLocking::revoke_at_safepoint(objects_to_revoke);
 }
 
+volatile int Deoptimization::_deoptimization_count = 0;
+
+void Deoptimization::increase_deoptimization_count() {
+  _deoptimization_count++;
+}
 
 void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
   assert(fr.can_be_deoptimized(), "checking frame type");
--- old/src/share/vm/runtime/deoptimization.hpp	2016-08-15 12:26:20.601019658 +0200
+++ new/src/share/vm/runtime/deoptimization.hpp	2016-08-15 12:26:20.433019658 +0200
@@ -135,7 +135,14 @@
   static void deoptimize(JavaThread* thread, frame fr, RegisterMap *reg_map);
   static void deoptimize(JavaThread* thread, frame fr, RegisterMap *reg_map, DeoptReason reason);
 
+  static void print_deoptimization_count();
+
   private:
+
+  static volatile int _deoptimization_count;
+
+  static void increase_deoptimization_count();
+
   // Does the actual work for deoptimizing a single frame
   static void deoptimize_single_frame(JavaThread* thread, frame fr, DeoptReason reason);
 
--- old/src/share/vm/runtime/globals.hpp	2016-08-15 12:26:21.093019658 +0200
+++ new/src/share/vm/runtime/globals.hpp	2016-08-15 12:26:20.941019658 +0200
@@ -1071,8 +1071,8 @@
           "Print native memory tracking summary data if it is on")          \
                                                                             \
   diagnostic(bool, LogCompilation, false,                                   \
-          "Log compilation activity in detail to LogFile")                  \
-                                                                            \
+		  "Log compilation activity in detail to LogFile")                  \
+																			\
   product(bool, PrintCompilation, false,                                    \
           "Print compilations")                                             \
                                                                             \
@@ -3560,7 +3560,45 @@
           "File containing compilation replay information"                  \
           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
                                                                             \
-   product(ccstr, InlineDataFile, NULL,                                     \
+  experimental(bool, DumpProfiles, false,                                   \
+          "Cache profiling information for future VM runs")                 \
+                                                                            \
+  experimental(intx, DumpProfilesMinTier, 3,                                \
+          "Specifies the minimum compilation tier that dumps"               \
+          "method profiles. Use 3 or 4"                                     \
+          "since methods lvl<3 do not get dumped anyway")                   \
+                                                                            \
+  experimental(bool, CacheProfiles, false,                                  \
+          "Use profiling information")                                      \
+                                                                            \
+  experimental(intx, CacheProfilesMode, 2,                                  \
+          "Mode in which CacheProfiling is operating: "                     \
+          "0 - lower threshold and compile to C2 directly; "                \
+          "1 - do not lower thresholds and"                                 \
+          "    compile to highest profile directly; "                       \
+          "2 - skip C1 profiling phase and"                                 \
+          "    keep everything else as standard; ")                         \
+                                                                            \
+  experimental(double, CacheProfilesMode0ThresholdScaling, 0.01,            \
+          "CompileThresholdScaling in case of mode0")                       \
+                                                                            \
+  experimental(ccstr, CacheProfilesFile, NULL,                              \
+          "File containing cached profiles"                                 \
+          "[default: ./profiles_pid%p.log] (%p replaced with pid)")         \
+                                                                            \
+  experimental(bool, PrintCacheProfiles, false,                             \
+           "Prints cache profiling information")                            \
+                                                                            \
+  experimental(bool, PrintDeoptimizationCount, false,                       \
+           "Prints count of deoptimizations at JVM shutdown")               \
+                                                                            \
+  experimental(bool, PrintDeoptimizationCountVerbose, false,                \
+           "Prints count of deoptimizations after each deopt")              \
+                                                                            \
+  experimental(bool, PrintCompileQueueSize, false,                          \
+           "Prints size of compile queue after each add")                   \
+                                                                            \
+  product(ccstr, InlineDataFile, NULL,                                      \
           "File containing inlining replay information"                     \
           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
                                                                             \
--- old/src/share/vm/runtime/java.cpp	2016-08-15 12:26:21.813019658 +0200
+++ new/src/share/vm/runtime/java.cpp	2016-08-15 12:26:21.621019658 +0200
@@ -312,6 +312,10 @@
     CodeCache::print();
   }
 
+  if (PrintDeoptimizationCount) {
+    Deoptimization::print_deoptimization_count();
+  }
+
   if (PrintMethodFlushingStatistics) {
     NMethodSweeper::print();
   }
@@ -371,6 +375,10 @@
     CodeCache::print();
   }
 
+  if (PrintDeoptimizationCount) {
+    Deoptimization::print_deoptimization_count();
+  }
+
   if (PrintMethodFlushingStatistics) {
     NMethodSweeper::print();
   }
--- old/src/share/vm/runtime/simpleThresholdPolicy.inline.hpp	2016-08-15 12:26:22.405019658 +0200
+++ new/src/share/vm/runtime/simpleThresholdPolicy.inline.hpp	2016-08-15 12:26:22.273019658 +0200
@@ -25,11 +25,36 @@
 #ifndef SHARE_VM_RUNTIME_SIMPLETHRESHOLDPOLICY_INLINE_HPP
 #define SHARE_VM_RUNTIME_SIMPLETHRESHOLDPOLICY_INLINE_HPP
 
+#include <ci/ciCacheProfiles.hpp>
 #include "compiler/compilerOracle.hpp"
 
 template<CompLevel level>
 bool SimpleThresholdPolicy::call_predicate_helper(int i, int b, double scale, Method* method) {
-  double threshold_scaling;
+  double threshold_scaling = 1.0;
+
+  if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+    if(CacheProfilesMode==0) {
+      switch(level) {
+      case CompLevel_none:
+      case CompLevel_limited_profile:
+        // if the compilation is Level 0 or 2 and therefore a Level 3
+        // compilation is next
+        // -> lower the Tier3 thresholds in case the method is cached
+        if(ciCacheProfiles::is_cached(method) >= CompLevel_full_profile) {
+          threshold_scaling = CacheProfilesMode0ThresholdScaling;
+          scale *= threshold_scaling;
+        }
+        break;
+      case CompLevel_full_profile:
+        // the Level 4 tresholds only get lowered if the profile is from C2
+        if(ciCacheProfiles::is_cached(method) == CompLevel_full_optimization) {
+          threshold_scaling = CacheProfilesMode0ThresholdScaling;
+          scale *= threshold_scaling;
+        }
+        break;
+      }
+    }
+  }
   if (CompilerOracle::has_option_value(method, "CompileThresholdScaling", threshold_scaling)) {
     scale *= threshold_scaling;
   }
@@ -47,7 +72,31 @@
 
 template<CompLevel level>
 bool SimpleThresholdPolicy::loop_predicate_helper(int i, int b, double scale, Method* method) {
-  double threshold_scaling;
+  double threshold_scaling = 1.0;
+
+  if(CacheProfiles && ciCacheProfiles::is_initialized()) {
+    if(CacheProfilesMode==0) {
+      switch(level) {
+      case CompLevel_none:
+      case CompLevel_limited_profile:
+        // if the compilation is Level 0 or 2 and therefore a Level 3
+        // compilation is next
+        // -> lower the Tier3 thresholds in case the method is cached
+        if(ciCacheProfiles::is_cached(method) >= CompLevel_full_profile) {
+          threshold_scaling = CacheProfilesMode0ThresholdScaling;
+          scale *= threshold_scaling;
+        }
+        break;
+      case CompLevel_full_profile:
+        // the Level 4 tresholds only get lowered if the profile is from C2
+        if(ciCacheProfiles::is_cached(method) == CompLevel_full_optimization) {
+          threshold_scaling = CacheProfilesMode0ThresholdScaling;
+          scale *= threshold_scaling;
+        }
+        break;
+      }
+    }
+  }
   if (CompilerOracle::has_option_value(method, "CompileThresholdScaling", threshold_scaling)) {
     scale *= threshold_scaling;
   }
--- old/src/share/vm/runtime/thread.cpp	2016-08-15 12:26:22.833019658 +0200
+++ new/src/share/vm/runtime/thread.cpp	2016-08-15 12:26:22.693019658 +0200
@@ -27,6 +27,7 @@
 #include "classfile/javaClasses.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "ci/ciCacheProfiles.hpp"
 #include "code/codeCache.hpp"
 #include "code/codeCacheExtensions.hpp"
 #include "code/scopeDesc.hpp"
@@ -3708,6 +3709,10 @@
   // initialize compiler(s)
 #if defined(COMPILER1) || defined(COMPILER2) || defined(SHARK) || INCLUDE_JVMCI
   CompileBroker::compilation_init(CHECK_JNI_ERR);
+  // if used, invoke initialization of CacheProfiles
+  if(CacheProfiles && !ciCacheProfiles::is_initialized()) {
+    ciCacheProfiles::initialize(THREAD);
+  }
 #endif
 
   // Pre-initialize some JSR292 core classes to avoid deadlock during class loading.
--- /dev/null	2016-08-11 14:11:23.983906000 +0200
+++ new/src/share/vm/ci/ciCacheProfiles.cpp	2016-08-15 12:26:23.401019658 +0200
@@ -0,0 +1,451 @@
+/* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "ci/ciMethodData.hpp"
+#include "ci/ciCacheProfiles.hpp"
+#include "ci/ciCacheReplay.hpp"
+#include "ci/ciSymbol.hpp"
+#include "ci/ciKlass.hpp"
+#include "ci/ciUtilities.hpp"
+#include "compiler/compileBroker.hpp"
+#include "compiler/compilerOracle.hpp"
+#include "memory/allocation.inline.hpp"
+#include "memory/oopFactory.hpp"
+#include "memory/resourceArea.hpp"
+#include "oops/oop.inline.hpp"
+#include "utilities/copy.hpp"
+#include "utilities/macros.hpp"
+
+const char* ciCacheProfiles::_error_message;
+const char* ciCacheProfiles::_CMD_COMPILE = "compile";
+
+FILE*   ciCacheProfiles::_stream = NULL;
+Thread* ciCacheProfiles::_thread = NULL;
+char* ciCacheProfiles::_bufptr = NULL;
+char* ciCacheProfiles::_buffer = NULL;
+int   ciCacheProfiles::_buffer_length = 0;
+int   ciCacheProfiles::_buffer_pos = 0;
+
+Dict* ciCacheProfiles::_compile_records_dictionary = NULL;
+Dict* ciCacheProfiles::_compile_records  = NULL;
+
+bool ciCacheProfiles::CacheIgnoreInitErrors = true;
+bool ciCacheProfiles::_initialized = false;
+
+bool ciCacheProfiles::had_error() {
+  return _error_message != NULL || _thread->has_pending_exception();
+}
+
+void ciCacheProfiles::report_error(const char* msg) {
+  _error_message = msg;
+  // Restore the _buffer contents for error reporting
+  for (int i = 0; i < _buffer_pos; i++) {
+    if (_buffer[i] == '\0') _buffer[i] = ' ';
+  }
+}
+
+int ciCacheProfiles::get_line(int c) {
+  while(c != EOF) {
+    if (_buffer_pos + 1 >= _buffer_length) {
+      int new_length = _buffer_length * 2;
+      // Next call will throw error in case of OOM.
+      _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);
+      _buffer_length = new_length;
+    }
+    if (c == '\n') {
+      _buffer[_buffer_pos++] = c;
+      c = getc(_stream); // get next char
+      break;
+    } else if (c == '\r') {
+      // skip LF
+    } else {
+      _buffer[_buffer_pos++] = c;
+    }
+    c = getc(_stream);
+  }
+  // null terminate it, reset the pointer
+  _buffer[_buffer_pos] = '\0'; // NL or EOF
+  _buffer_pos = 0;
+  _bufptr = _buffer;
+  return c;
+}
+
+int ciCacheProfiles::parse_int(const char* label) {
+  if (had_error()) {
+    return 0;
+  }
+
+  int v = 0;
+  int read;
+  if (sscanf(_bufptr, "%i%n", &v, &read) != 1) {
+    report_error(label);
+  } else {
+    _bufptr += read;
+  }
+  return v;
+}
+
+void ciCacheProfiles::skip_ws() {
+  // Skip any leading whitespace
+  while (*_bufptr == ' ' || *_bufptr == '\t') {
+    _bufptr++;
+  }
+}
+
+char* ciCacheProfiles::scan_and_terminate(char delim) {
+  char* str = _bufptr;
+  while (*_bufptr != delim && *_bufptr != '\0') {
+    _bufptr++;
+  }
+  if (*_bufptr != '\0') {
+    *_bufptr++ = '\0';
+  }
+  if (_bufptr == str) {
+    // nothing here
+    return NULL;
+  }
+  return str;
+}
+// Take an ascii string contain \u#### escapes and convert it to utf8
+  // in place.
+void ciCacheProfiles::unescape_string(char* value) {
+char* from = value;
+char* to = value;
+while (*from != '\0') {
+  if (*from != '\\') {
+	*from++ = *to++;
+  } else {
+	switch (from[1]) {
+	  case 'u': {
+		from += 2;
+		jchar value=0;
+		for (int i=0; i<4; i++) {
+		  char c = *from++;
+		  switch (c) {
+			case '0': case '1': case '2': case '3': case '4':
+			case '5': case '6': case '7': case '8': case '9':
+			  value = (value << 4) + c - '0';
+			  break;
+			case 'a': case 'b': case 'c':
+			case 'd': case 'e': case 'f':
+			  value = (value << 4) + 10 + c - 'a';
+			  break;
+			case 'A': case 'B': case 'C':
+			case 'D': case 'E': case 'F':
+			  value = (value << 4) + 10 + c - 'A';
+			  break;
+			default:
+			  ShouldNotReachHere();
+		  }
+		}
+		UNICODE::convert_to_utf8(&value, 1, to);
+		to++;
+		break;
+	  }
+	  case 't': *to++ = '\t'; from += 2; break;
+	  case 'n': *to++ = '\n'; from += 2; break;
+	  case 'r': *to++ = '\r'; from += 2; break;
+	  case 'f': *to++ = '\f'; from += 2; break;
+	  default:
+		ShouldNotReachHere();
+	}
+  }
+}
+*from = *to;
+}
+char* ciCacheProfiles::parse_quoted_string() {
+  if (had_error()) return NULL;
+
+  skip_ws();
+
+  if (*_bufptr == '"') {
+    _bufptr++;
+    return scan_and_terminate('"');
+  } else {
+    return scan_and_terminate(' ');
+  }
+}
+
+const char* ciCacheProfiles::parse_escaped_string() {
+  char* result = parse_quoted_string();
+  if (result != NULL) {
+    unescape_string(result);
+  }
+  return result;
+}
+
+char* ciCacheProfiles::parse_string() {
+  if (had_error()) return NULL;
+
+  skip_ws();
+  return scan_and_terminate(' ');
+}
+
+bool ciCacheProfiles::can_replay() {
+  return !(_stream == NULL || had_error());
+}
+const char* ciCacheProfiles::error_message() {
+  return _error_message;
+}
+
+void ciCacheProfiles::replay(TRAPS, Method* method, int osr_bci, bool blocked) {
+  _thread = THREAD;
+  int exit_code = replay_impl(THREAD, method, osr_bci, blocked);
+}
+
+int ciCacheProfiles::replay_impl(TRAPS, Method* method, int osr_bci, bool blocked) {
+  HandleMark hm;
+  ResourceMark rm;
+
+  int exit_code = 0;
+  if (can_replay()) {
+    replay_method(THREAD, method, osr_bci, blocked);
+  } else {
+    exit_code = 1;
+    return exit_code;
+  }
+
+  if (HAS_PENDING_EXCEPTION) {
+    oop throwable = PENDING_EXCEPTION;
+    CLEAR_PENDING_EXCEPTION;
+    java_lang_Throwable::print(throwable, tty);
+    tty->cr();
+    java_lang_Throwable::print_stack_trace(throwable, tty);
+    tty->cr();
+    exit_code = 2;
+  }
+
+  if (had_error()) {
+    tty->print_cr("Failed on %s", error_message());
+    exit_code = 1;
+  }
+  return exit_code;
+}
+
+void ciCacheProfiles::replay_method(TRAPS, Method* method, int osr_bci, bool blocked) {
+	char* key = get_key(method);
+	char* rec = (char*) (*_compile_records_dictionary)[key];
+	if(rec!=NULL) {
+		if(PrintCacheProfiles) tty->print_cr("Found method %s in dictionary", key);
+		ciCacheReplay::replay_cached(THREAD, rec, osr_bci, blocked);
+	}  else {
+	    if(PrintCacheProfiles) tty->print_cr("Could not find method %s in dictionary.", key);
+	}
+}
+
+// initialize the cache profiler and parse the profile file
+// to save methods in the ciCompileRecords array
+void ciCacheProfiles::initialize(TRAPS) {
+  if (!is_initialized()) {
+    HandleMark hm;
+    ResourceMark rm;
+    if (FLAG_IS_DEFAULT(CacheProfilesFile)) {
+      tty->print_cr("NOTE: no explicit compiler cache profiles file specified, uses -XX:CacheProfilesFile=cached_profiles.dat.");
+      CacheProfilesFile = "cached_profiles.dat";
+    }
+
+    // Load and parse the replay data
+    // initialize variables (these were part of the cache before)
+    _thread = THREAD;
+
+    _stream = fopen(CacheProfilesFile, "rt");
+    if (_stream == NULL) {
+      fprintf(stderr, "ERROR: Can't open cache profile %s\n", CacheProfilesFile);
+    }
+
+    _error_message = NULL;
+
+    _buffer_length = 32;
+    _buffer =  NEW_RESOURCE_ARRAY(char, _buffer_length);
+    _bufptr = _buffer;
+    _buffer_pos = 0;
+
+    Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
+    Arena* shared_type_arena2 = new (mtCompiler)Arena(mtCompiler);
+    _compile_records = new (shared_type_arena) Dict(cmpstr, hashstr, shared_type_arena);
+    _compile_records_dictionary = new (shared_type_arena2) Dict(cmpstr, hashstr, shared_type_arena2);
+
+    if (can_replay()) {
+      process_file(THREAD);
+    }
+
+    if (HAS_PENDING_EXCEPTION) {
+      oop throwable = PENDING_EXCEPTION;
+      CLEAR_PENDING_EXCEPTION;
+      java_lang_Throwable::print(throwable, tty);
+      tty->cr();
+      java_lang_Throwable::print_stack_trace(throwable, tty);
+      tty->cr();
+    }
+
+    if (had_error()) {
+      tty->print_cr("Processing failed on %s", error_message());
+    }
+  }
+  is_initialized(true);
+  if (PrintCacheProfiles) {
+    tty->print_cr("CacheProfiles: CachedProfiles initialized!");
+  }
+}
+
+bool ciCacheProfiles::is_initialized() {
+  return _initialized;
+}
+
+void ciCacheProfiles::is_initialized(bool flag) {
+  _initialized = flag;
+}
+
+char* ciCacheProfiles::get_key(Method* method) {
+	char* klass_name =  method->method_holder()->name()->as_utf8();
+	char* method_name = method->name()->as_utf8();
+	char* signature = method->signature()->as_utf8();
+	char* key = get_key(klass_name, method_name, signature);
+	return key;
+}
+
+char* ciCacheProfiles::get_key(methodHandle method) {
+	char* klass_name =  method->method_holder()->name()->as_utf8();
+	char* method_name = method->name()->as_utf8();
+	char* signature = method->signature()->as_utf8();
+	char* key = get_key(klass_name, method_name, signature);
+	return key;
+}
+
+char* ciCacheProfiles::get_key(const char* klass_name, const char* method_name, const char* signature) {
+	char* key = NEW_C_HEAP_ARRAY(char, (unsigned)strlen(klass_name)+(unsigned)strlen(method_name)+(unsigned)strlen(signature)+3, mtCompiler);
+	strcpy(key, klass_name);
+	strcpy(key+(unsigned)strlen(klass_name), "::");
+	strcpy(key+(unsigned)strlen(klass_name)+2, method_name);
+	strcpy(key+(unsigned)strlen(klass_name)+2+(unsigned)strlen(method_name), signature);
+	return key;
+}
+
+// returns the complevel if cached, else 0
+int ciCacheProfiles::is_cached(Method* method) {
+	if (!is_initialized()) {
+	return 0;
+	}
+	//VM_ENTRY_MARK;
+	ASSERT_IN_VM;
+	ResourceMark rm;
+	char* key = get_key(method);
+	char* rec = (char*) (*_compile_records)[key];
+	if(rec == NULL) {
+		return 0;
+	} else {
+		return atoi(rec);
+	}
+}
+
+// same function for a method holder
+int ciCacheProfiles::is_cached(methodHandle method) {
+	if (!is_initialized()) {
+		return 0;
+	}
+	//VM_ENTRY_MARK;
+	ASSERT_IN_VM;
+	ResourceMark rm;
+	char* key = get_key(method);
+	char* rec =  (char*) (*_compile_records)[key];
+	if(rec == NULL) {
+		return 0;
+	} else {
+		return atoi(rec);
+	}
+}
+// returns the complevel if cached, else 0
+int ciCacheProfiles::is_cached(char* key) {
+	char* rec = (char*) (*_compile_records)[key];
+	if(rec == NULL) {
+		return 0;
+	} else {
+		return atoi(rec);
+	}
+}
+// Process each line of the replay file and store in hashmap
+void ciCacheProfiles::process_file(TRAPS) {
+	int line_no = 1;
+	int c = getc(_stream);
+    int process_buffer_length = 1024;
+    char* process_buffer = NEW_C_HEAP_ARRAY(char, process_buffer_length, mtCompiler);
+    int process_buffer_pos = 0;
+	while(c != EOF) {
+		c = get_line(c);
+		bool isCompileEntry = true;
+		for(int i = 0; i < 7; i++) {
+			if(_buffer[i] != _CMD_COMPILE[i]) {
+				isCompileEntry = false;
+				break;
+			}
+		}
+		// now copy the content of _buffer to process_buffer and terminate with \n (newline)
+		int i = 0;
+		while(_buffer[i] != '\n') {
+			process_buffer[process_buffer_pos++] = _buffer[i];
+			i++;
+			if(process_buffer_pos + 2 >= process_buffer_length) {
+				// if the process buffer is out of space we need to grow it
+				process_buffer_length = process_buffer_length * 2;
+				// Next call will throw error in case of OOM.
+				process_buffer = REALLOC_C_HEAP_ARRAY(char, process_buffer, process_buffer_length, mtCompiler);
+			}
+		}
+		process_buffer[process_buffer_pos++] = '\n';
+		// if it's a compile entry start a new dictionary entry and save the current one
+		if(isCompileEntry) {
+			process_buffer[process_buffer_pos++] = EOF;
+			// backup the content of the process buffer
+			char* value = NEW_C_HEAP_ARRAY(char, process_buffer_pos, mtCompiler);
+			strncpy(value, process_buffer, process_buffer_pos);
+			// first parse string is to eliminate the 'compile' keyword
+			parse_string();
+			const char* klass_name = parse_escaped_string();
+			const char* method_name = parse_escaped_string();
+			const char* signature = parse_escaped_string();
+			int entry_bci = parse_int("entry_bci");
+			int comp_level = parse_int("comp_level");
+			// old version w/o comp_level
+			if (had_error() && (error_message() == "comp_level")) {
+				comp_level = CompLevel_full_optimization;
+			}
+			char* key = get_key(klass_name, method_name, signature);
+			if(comp_level >= is_cached(key)) {
+				_compile_records_dictionary->Insert(key, value, true);
+				char* integer = NEW_C_HEAP_ARRAY(char, 2, mtCompiler);
+				sprintf(integer, "%d", comp_level);
+				_compile_records->Insert(key, integer, true);
+
+			}
+
+			// reset processing datastructure
+		    process_buffer = REALLOC_C_HEAP_ARRAY(char, process_buffer, 1024, mtCompiler);
+		    process_buffer_length = 1024;
+		    process_buffer_pos = 0;
+		   // FREE_C_HEAP_ARRAY(char, value);
+		}
+		//FREE_C_HEAP_ARRAY(char, process_buffer);
+		line_no++;
+	}
+}
--- /dev/null	2016-08-11 14:11:23.983906000 +0200
+++ new/src/share/vm/ci/ciCacheProfiles.hpp	2016-08-15 12:26:23.981019658 +0200
@@ -0,0 +1,153 @@
+/*
+ciCacheProfiles.cpp * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_CI_CICACHEPROFILES_HPP
+#define SHARE_VM_CI_CICACHEPROFILES_HPP
+
+#include "ci/ciMethod.hpp"
+//#include "libadt/dict.hpp"
+
+// -------------------
+// ciCacheProfiles & ciCacheReplay
+// -------------------
+//
+// Cache profiling information of a java method to disk and retrieve this data
+// in further executions of the JVM.
+//
+// NOTE: this functionality is only enabled in "experimental mode"
+// (flag: -XX:+UnlockExperimentalVMOptions)
+//
+// -------------------
+// Dump profile data.
+// -------------------
+//
+// Use the flag -XX:+DumpProfiles to dump all compiled methods to disk (cached_profiles.dat)
+//
+// One can also specify the flags DumpProfile or IgnoreDumpProfile as CompileCommand
+// for specific method inclusions / exclusions
+// e.g. -XX:CompileCommand=option,Benchmark::test,DumpProfile
+//
+// -------------------
+// Use profile data.
+// -------------------
+//
+// The flag -XX:+CacheProfiles tells the VM to use cached profiles when available
+// Before any compilation happen this class scans through the txt file and builds
+// the datastructure (consider the linear overhead).
+// One can also specify a profiles file with -XX:CacheProfilesFile=foo.txt
+//
+// CacheProfiles can be used in 3 different modes:
+// with flag -XX:CacheProfilesMode={0,1,2}
+//
+// Mode 0: lower the compilation threshold scaling of cached methods automatically
+//         to 0.01 of cached methods automatically so they get compiled
+//         earlier and with the highest available profile (usually C2)
+//         One can use a different value than 0.01 by using the flag
+//         -XX:CacheProfilesMode0ThresholdScaling=x.xx
+// Mode 1: do not lower the thresholds but once a compilation is triggered
+//         use highest available profile (usually C2)
+// Mode 2: do not lower the thresholds but use compile level 2 (limited profiles)
+//         instead of compile level 3 (full profiles) when a cached method gets
+//         compiled with C1.
+//         The idea is that this method already has enough profiles (on disk)
+//         available so we get a faster C1 phase.
+//         C2 will still use the cached profile like in other modes.
+//
+// -------------------
+// Debug flags.
+// -------------------
+//
+// -XX:+PrintCacheProfiles - prints debug information about cache profiles thread
+// -XX:+PrintDeoptimizationCount - prints deoptimization count after JVM execution
+// -XX:+PrintDeoptimizationCountVerbose - prints deopt count after each compilation
+// -XX:+PrintCompileQueueSize - print size of compile queue after each compilation
+//
+// This class contains the functionality of CacheProfiles that interact
+// with the CompileBroker when cached profiles are loaded.
+// ciCacheReplay is basically an extended and modified copy of ciReplay
+class ciCacheProfiles : public AllStatic {
+  CI_PACKAGE_ACCESS
+  friend class ciCacheReplay;
+  friend class CacheCompileReplay;
+private:
+
+  static bool had_error();
+  static void report_error(const char* msg);
+
+  static int get_line(int c);
+  static int parse_int(const char* label);
+  static void skip_ws();
+  static char* scan_and_terminate(char delim);
+  // new
+  static void unescape_string(char* value);
+  static char* parse_quoted_string();
+  static const char* parse_escaped_string();
+  // notnew
+  static char* parse_string();
+
+  static bool can_replay();
+
+  static const char* error_message();
+
+  static int replay_impl(TRAPS, Method* method, int osr_bci, bool blocked);
+  static void replay_method(TRAPS, Method* method, int osr_bci, bool blocked);
+
+  static void process_file(TRAPS);
+
+  static char* get_key(Method* method);
+  static char* get_key(methodHandle method);
+  static char* get_key(const char* klass_name, const char* method_name, const char* signature);
+  static int is_cached(char* key);
+
+  static const char* _error_message;
+  static const char* _CMD_COMPILE;
+
+  static FILE*   _stream;
+  static Thread* _thread;
+
+  static char* _bufptr;
+  static char* _buffer;
+  static int   _buffer_length;
+  static int   _buffer_pos;
+
+  static bool _initialized;
+  static bool CacheIgnoreInitErrors;
+
+  static Dict* _compile_records_dictionary;
+  static Dict* _compile_records;
+
+public:
+  // Replay specified compilation
+  static void replay(TRAPS, Method* method, int osr_bci, bool blocked);
+
+  static void initialize(TRAPS);
+
+  static bool is_initialized();
+  static void is_initialized(bool flag);
+
+  static int is_cached(methodHandle method);
+  static int is_cached(Method* method);
+};
+
+#endif // SHARE_VM_CI_CICACHEPROFILES_HPP
--- /dev/null	2016-08-11 14:11:23.983906000 +0200
+++ new/src/share/vm/ci/ciCacheReplay.cpp	2016-08-15 12:26:24.365019658 +0200
@@ -0,0 +1,1198 @@
+/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "ci/ciMethodData.hpp"
+#include "ci/ciCacheReplay.hpp"
+#include "ci/ciCacheProfiles.hpp"
+#include "ci/ciSymbol.hpp"
+#include "ci/ciKlass.hpp"
+#include "ci/ciUtilities.hpp"
+#include "compiler/compileBroker.hpp"
+#include "memory/allocation.inline.hpp"
+#include "memory/oopFactory.hpp"
+#include "memory/resourceArea.hpp"
+#include "oops/oop.inline.hpp"
+#include "utilities/copy.hpp"
+#include "utilities/macros.hpp"
+
+//#ifndef PRODUCT
+
+// ciCacheReplay
+
+typedef struct _ciMethodDataRecord {
+  const char* _klass_name;
+  const char* _method_name;
+  const char* _signature;
+
+  int _state;
+  int _current_mileage;
+
+  intptr_t* _data;
+  char*     _orig_data;
+  Klass**   _classes;
+  Method**  _methods;
+  int*      _classes_offsets;
+  int*      _methods_offsets;
+  int       _data_length;
+  int       _orig_data_length;
+  int       _classes_length;
+  int       _methods_length;
+} ciMethodDataRecord;
+
+typedef struct _ciMethodRecord {
+  const char* _klass_name;
+  const char* _method_name;
+  const char* _signature;
+
+  int _instructions_size;
+  int _interpreter_invocation_count;
+  int _interpreter_throwout_count;
+  int _invocation_counter;
+  int _backedge_counter;
+} ciMethodRecord;
+
+typedef struct _ciInlineRecord {
+  const char* _klass_name;
+  const char* _method_name;
+  const char* _signature;
+
+  int _inline_depth;
+  int _inline_bci;
+} ciInlineRecord;
+
+class  CacheCompileReplay;
+static CacheCompileReplay* replay_state;
+
+class CacheCompileReplay : public StackObj {
+ private:
+  char*   _stream;
+  int     _stream_index;
+  Thread* _thread;
+  Handle  _protection_domain;
+  Handle  _loader;
+
+  GrowableArray<ciMethodRecord*>     _ci_method_records;
+  GrowableArray<ciMethodDataRecord*> _ci_method_data_records;
+
+  // Use pointer because we may need to return inline records
+  // without destroying them.
+  GrowableArray<ciInlineRecord*>*    _ci_inline_records;
+
+  const char* _error_message;
+
+  char* _bufptr;
+  char* _buffer;
+  int   _buffer_length;
+  int   _buffer_pos;
+
+  // "compile" data
+  ciKlass* _iklass;
+  Method*  _imethod;
+  int      _entry_bci;
+  int      _comp_level;
+  int      _osr_bci;
+  bool     _blocked;
+
+ public:
+  CacheCompileReplay(char* unparsed_data, TRAPS, int osr_bci, bool blocked) {
+    _thread = THREAD;
+    _loader = Handle(_thread, SystemDictionary::java_system_loader());
+    _protection_domain = Handle();
+
+    _stream = unparsed_data;
+    _stream_index = 0;
+    if (_stream == NULL) {
+      fprintf(stderr, "ERROR: Can't open replay data\n");
+    }
+
+    _ci_inline_records = NULL;
+    _error_message = NULL;
+
+    _buffer_length = 32;
+    _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);
+    _bufptr = _buffer;
+    _buffer_pos = 0;
+
+    _imethod = NULL;
+    _iklass  = NULL;
+    _entry_bci  = 0;
+    _comp_level = 0;
+
+    _blocked = blocked;
+    _osr_bci = osr_bci;
+  }
+
+  ~CacheCompileReplay() {
+    if (_stream != NULL) {
+    	//_stream_index = 0;
+    	//free(_stream);
+    }
+  }
+
+  bool had_error() {
+    return _error_message != NULL || _thread->has_pending_exception();
+  }
+
+  bool can_replay() {
+    return !(_stream == NULL || had_error());
+  }
+
+  void report_error(const char* msg) {
+    _error_message = msg;
+    // Restore the _buffer contents for error reporting
+    for (int i = 0; i < _buffer_pos; i++) {
+      if (_buffer[i] == '\0') _buffer[i] = ' ';
+    }
+  }
+
+  int parse_int(const char* label) {
+    if (had_error()) {
+      return 0;
+    }
+
+    int v = 0;
+    int read;
+    if (sscanf(_bufptr, "%i%n", &v, &read) != 1) {
+      report_error(label);
+    } else {
+      _bufptr += read;
+    }
+    return v;
+  }
+
+  intptr_t parse_intptr_t(const char* label) {
+    if (had_error()) {
+      return 0;
+    }
+
+    intptr_t v = 0;
+    int read;
+    if (sscanf(_bufptr, INTPTR_FORMAT "%n", &v, &read) != 1) {
+      report_error(label);
+    } else {
+      _bufptr += read;
+    }
+    return v;
+  }
+
+  void skip_ws() {
+    // Skip any leading whitespace
+    while (*_bufptr == ' ' || *_bufptr == '\t') {
+      _bufptr++;
+    }
+  }
+
+
+  char* scan_and_terminate(char delim) {
+    char* str = _bufptr;
+    while (*_bufptr != delim && *_bufptr != '\0') {
+      _bufptr++;
+    }
+    if (*_bufptr != '\0') {
+      *_bufptr++ = '\0';
+    }
+    if (_bufptr == str) {
+      // nothing here
+      return NULL;
+    }
+    return str;
+  }
+
+  char* parse_string() {
+    if (had_error()) return NULL;
+
+    skip_ws();
+    return scan_and_terminate(' ');
+  }
+
+  char* parse_quoted_string() {
+    if (had_error()) return NULL;
+
+    skip_ws();
+
+    if (*_bufptr == '"') {
+      _bufptr++;
+      return scan_and_terminate('"');
+    } else {
+      return scan_and_terminate(' ');
+    }
+  }
+
+  const char* parse_escaped_string() {
+    char* result = parse_quoted_string();
+    if (result != NULL) {
+      unescape_string(result);
+    }
+    return result;
+  }
+
+  // Look for the tag 'tag' followed by an
+  bool parse_tag_and_count(const char* tag, int& length) {
+    const char* t = parse_string();
+    if (t == NULL) {
+      return false;
+    }
+
+    if (strcmp(tag, t) != 0) {
+      report_error(tag);
+      return false;
+    }
+    length = parse_int("parse_tag_and_count");
+    return !had_error();
+  }
+
+  // Parse a sequence of raw data encoded as bytes and return the
+  // resulting data.
+  char* parse_data(const char* tag, int& length) {
+    if (!parse_tag_and_count(tag, length)) {
+      return NULL;
+    }
+
+    char * result = NEW_RESOURCE_ARRAY(char, length);
+    for (int i = 0; i < length; i++) {
+      int val = parse_int("data");
+      result[i] = val;
+    }
+    return result;
+  }
+
+  // Parse a standard chunk of data emitted as:
+  //   'tag' <length> # # ...
+  // Where each # is an intptr_t item
+  intptr_t* parse_intptr_data(const char* tag, int& length) {
+    if (!parse_tag_and_count(tag, length)) {
+      return NULL;
+    }
+
+    intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
+    for (int i = 0; i < length; i++) {
+      skip_ws();
+      intptr_t val = parse_intptr_t("data");
+      result[i] = val;
+    }
+    return result;
+  }
+
+  // Parse a possibly quoted version of a symbol into a symbolOop
+  Symbol* parse_symbol(TRAPS) {
+    const char* str = parse_escaped_string();
+    if (str != NULL) {
+      Symbol* sym = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);
+      return sym;
+    }
+    return NULL;
+  }
+
+  // Parse a valid klass name and look it up
+  Klass* parse_klass(TRAPS) {
+    const char* str = parse_escaped_string();
+    Symbol* klass_name = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);
+    if (klass_name != NULL) {
+      Klass* k = NULL;
+      if (_iklass != NULL) {
+        k = (Klass*)_iklass->find_klass(ciSymbol::make(klass_name->as_C_string()))->constant_encoding();
+      } else {
+        k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
+      }
+      if (HAS_PENDING_EXCEPTION) {
+        oop throwable = PENDING_EXCEPTION;
+        java_lang_Throwable::print(throwable, tty);
+        tty->cr();
+        report_error(str);
+        return NULL;
+      }
+      return k;
+    }
+    return NULL;
+  }
+
+  // Lookup a klass
+  Klass* resolve_klass(const char* klass, TRAPS) {
+    Symbol* klass_name = SymbolTable::lookup(klass, (int)strlen(klass), CHECK_NULL);
+    return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
+  }
+
+  // Parse the standard tuple of <klass> <name> <signature>
+  Method* parse_method(TRAPS) {
+    InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
+    Symbol* method_name = parse_symbol(CHECK_NULL);
+    Symbol* method_signature = parse_symbol(CHECK_NULL);
+    Method* m = k->find_method(method_name, method_signature);
+    if (m == NULL) {
+      report_error("Can't find method");
+    }
+    return m;
+  }
+
+  int get_line(int c) {
+    while(c != EOF) {
+      if (_buffer_pos + 1 >= _buffer_length) {
+        int new_length = _buffer_length * 2;
+        // Next call will throw error in case of OOM.
+        _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);
+        _buffer_length = new_length;
+      }
+      if (c == '\n') {
+    	c = _stream[_stream_index++]; // get next char
+        break;
+      } else if (c == '\r') {
+        // skip LF
+      } else {
+        _buffer[_buffer_pos++] = c;
+      }
+      c = _stream[_stream_index++];
+    }
+    // null terminate it, reset the pointer
+    _buffer[_buffer_pos] = '\0'; // NL or EOF
+    _buffer_pos = 0;
+    _bufptr = _buffer;
+    return c;
+  }
+
+  // Process each line of the replay file executing each command until
+  // the file ends.
+  void process(TRAPS) {
+    int line_no = 1;
+    int c = _stream[_stream_index++];
+    while(c != EOF) {
+      c = get_line(c);
+      process_command(THREAD);
+      if (had_error()) {
+        tty->print_cr("Error while parsing line %d: %s\n", line_no, _error_message);
+        if (ciCacheProfiles::CacheIgnoreInitErrors) {
+          CLEAR_PENDING_EXCEPTION;
+          _error_message = NULL;
+        } else {
+          return;
+        }
+      }
+      line_no++;
+    }
+  }
+
+  void process_command(TRAPS) {
+    char* cmd = parse_string();
+    if (cmd == NULL) {
+      return;
+    }
+    if (strcmp("#", cmd) == 0) {
+      // ignore
+    } else if (strcmp("compile", cmd) == 0) {
+      process_compile(CHECK);
+    } else if (strcmp("ciMethod", cmd) == 0) {
+      process_ciMethod(CHECK);
+    } else if (strcmp("ciMethodData", cmd) == 0) {
+      process_ciMethodData(CHECK);
+    } else if (strcmp("staticfield", cmd) == 0) {
+      process_staticfield(CHECK);
+    } else if (strcmp("ciInstanceKlass", cmd) == 0) {
+      process_ciInstanceKlass(CHECK);
+    } else if (strcmp("instanceKlass", cmd) == 0) {
+      process_instanceKlass(CHECK);
+#if INCLUDE_JVMTI
+    } else if (strcmp("JvmtiExport", cmd) == 0) {
+      process_JvmtiExport(CHECK);
+#endif // INCLUDE_JVMTI
+    } else {
+    	// TODO maybe throw a more reasonable error message
+      //report_error("unknown command");
+    }
+  }
+
+  // validation of comp_level
+  bool is_valid_comp_level(int comp_level) {
+    const int msg_len = 256;
+    char* msg = NULL;
+    if (!is_compile(comp_level)) {
+      msg = NEW_RESOURCE_ARRAY(char, msg_len);
+      jio_snprintf(msg, msg_len, "%d isn't compilation level", comp_level);
+    } else if (!TieredCompilation && (comp_level != CompLevel_highest_tier)) {
+      msg = NEW_RESOURCE_ARRAY(char, msg_len);
+      switch (comp_level) {
+        case CompLevel_simple:
+          jio_snprintf(msg, msg_len, "compilation level %d requires Client VM or TieredCompilation", comp_level);
+          break;
+        case CompLevel_full_optimization:
+          jio_snprintf(msg, msg_len, "compilation level %d requires Server VM", comp_level);
+          break;
+        default:
+          jio_snprintf(msg, msg_len, "compilation level %d requires TieredCompilation", comp_level);
+      }
+    }
+    if (msg != NULL) {
+      report_error(msg);
+      return false;
+    }
+    return true;
+  }
+
+  // compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> <depth> <bci> <klass> <name> <signature> ...
+  void* process_inline(ciMethod* imethod, Method* m, int entry_bci, int comp_level, TRAPS) {
+    _imethod    = m;
+    _iklass     = imethod->holder();
+    _entry_bci  = entry_bci;
+    _comp_level = comp_level;
+    int line_no = 1;
+    int c = _stream[_stream_index++];
+    while(c != EOF) {
+      c = get_line(c);
+      // Expecting only lines with "compile" command in inline replay file.
+      char* cmd = parse_string();
+      if (cmd == NULL || strcmp("compile", cmd) != 0) {
+        return NULL;
+      }
+      process_compile(CHECK_NULL);
+      if (had_error()) {
+        tty->print_cr("Error while parsing line %d: %s\n", line_no, _error_message);
+        tty->print_cr("%s", _buffer);
+        return NULL;
+      }
+      if (_ci_inline_records != NULL && _ci_inline_records->length() > 0) {
+        // Found inlining record for the requested method.
+        return _ci_inline_records;
+      }
+      line_no++;
+    }
+    return NULL;
+  }
+
+  // compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> <depth> <bci> <klass> <name> <signature> ...
+  void process_compile(TRAPS) {
+    Method* method = parse_method(CHECK);
+    if (had_error()) return;
+    int entry_bci = parse_int("entry_bci");
+    const char* comp_level_label = "comp_level";
+    int comp_level = parse_int(comp_level_label);
+    // old version w/o comp_level
+    if (had_error() && (error_message() == comp_level_label)) {
+      comp_level = CompLevel_full_optimization;
+    }
+    if (!is_valid_comp_level(comp_level)) {
+      return;
+    }
+    if (_imethod != NULL) {
+      // Replay Inlining
+      if (entry_bci != _entry_bci || comp_level != _comp_level) {
+        return;
+      }
+      const char* iklass_name  = _imethod->method_holder()->name()->as_utf8();
+      const char* imethod_name = _imethod->name()->as_utf8();
+      const char* isignature   = _imethod->signature()->as_utf8();
+      const char* klass_name   = method->method_holder()->name()->as_utf8();
+      const char* method_name  = method->name()->as_utf8();
+      const char* signature    = method->signature()->as_utf8();
+      if (strcmp(iklass_name,  klass_name)  != 0 ||
+          strcmp(imethod_name, method_name) != 0 ||
+          strcmp(isignature,   signature)   != 0) {
+        return;
+      }
+    }
+    int inline_count = 0;
+    if (parse_tag_and_count("inline", inline_count)) {
+      // Record inlining data
+      _ci_inline_records = new GrowableArray<ciInlineRecord*>();
+      for (int i = 0; i < inline_count; i++) {
+        int depth = parse_int("inline_depth");
+        int bci = parse_int("inline_bci");
+        if (had_error()) {
+          break;
+        }
+        Method* inl_method = parse_method(CHECK);
+        if (had_error()) {
+          break;
+        }
+        new_ciInlineRecord(inl_method, bci, depth);
+      }
+    }
+    if(PrintCacheProfiles) tty->print_cr("Inline count: %i", inline_count);
+    if (_imethod != NULL) {
+      return; // Replay Inlining
+    }
+    InstanceKlass* ik = method->method_holder();
+    ik->initialize(THREAD);
+    if (HAS_PENDING_EXCEPTION) {
+      oop throwable = PENDING_EXCEPTION;
+      java_lang_Throwable::print(throwable, tty);
+      tty->cr();
+      if (ciCacheProfiles::CacheIgnoreInitErrors) {
+        CLEAR_PENDING_EXCEPTION;
+        ik->set_init_state(InstanceKlass::fully_initialized);
+      } else {
+        return;
+      }
+    }
+    // Make sure the existence of a prior compile doesn't stop this one
+    nmethod* nm = (entry_bci != InvocationEntryBci) ? method->lookup_osr_nmethod_for(_osr_bci, comp_level, true) : method->code();
+    if (nm != NULL) {
+      nm->make_not_entrant();
+    }
+    replay_state = this;
+    // now use compile_method_base instead of compile_method to process further in the compilation
+    CompileBroker::compile_method_base(method, _osr_bci, comp_level,
+                                  methodHandle(), 0, "replay", THREAD);
+//    CompileBroker::compile_method_base(method, _osr_bci, comp_level,
+//                                  methodHandle(), 0, "replay", _blocked, THREAD);
+    replay_state = NULL;
+    reset();
+  }
+
+  // ciMethod <klass> <name> <signature> <invocation_counter> <backedge_counter> <interpreter_invocation_count> <interpreter_throwout_count> <instructions_size>
+  //
+  //
+  void process_ciMethod(TRAPS) {
+    Method* method = parse_method(CHECK);
+    if (had_error()) return;
+    ciMethodRecord* rec = new_ciMethod(method);
+    rec->_invocation_counter = parse_int("invocation_counter");
+    rec->_backedge_counter = parse_int("backedge_counter");
+    rec->_interpreter_invocation_count = parse_int("interpreter_invocation_count");
+    rec->_interpreter_throwout_count = parse_int("interpreter_throwout_count");
+    rec->_instructions_size = parse_int("instructions_size");
+  }
+
+  // ciMethodData <klass> <name> <signature> <state> <current mileage> orig <length> # # ... data <length> # # ... oops <length> # ... methods <length>
+  void process_ciMethodData(TRAPS) {
+    Method* method = parse_method(CHECK);
+    if (had_error()) return;
+    /* just copied from Method, to build interpret data*/
+    if (InstanceRefKlass::owns_pending_list_lock((JavaThread*)THREAD)) {
+      return;
+    }
+    // To be properly initialized, some profiling in the MDO needs the
+    // method to be rewritten (number of arguments at a call for
+    // instance)
+    method->method_holder()->link_class(CHECK);
+    // methodOopDesc::build_interpreter_method_data(method, CHECK);
+    {
+      // Grab a lock here to prevent multiple
+      // MethodData*s from being created.
+      MutexLocker ml(MethodData_lock, THREAD);
+      if (method->method_data() == NULL) {
+        ClassLoaderData* loader_data = method->method_holder()->class_loader_data();
+        MethodData* method_data = MethodData::allocate(loader_data, method, CHECK);
+        method->set_method_data(method_data);
+      }
+    }
+
+    // collect and record all the needed information for later
+    ciMethodDataRecord* rec = new_ciMethodData(method);
+    rec->_state = parse_int("state");
+    rec->_current_mileage = parse_int("current_mileage");
+
+    rec->_orig_data = parse_data("orig", rec->_orig_data_length);
+    if (rec->_orig_data == NULL) {
+      return;
+    }
+    rec->_data = parse_intptr_data("data", rec->_data_length);
+    if (rec->_data == NULL) {
+      return;
+    }
+    if (!parse_tag_and_count("oops", rec->_classes_length)) {
+      return;
+    }
+    rec->_classes = NEW_RESOURCE_ARRAY(Klass*, rec->_classes_length);
+    rec->_classes_offsets = NEW_RESOURCE_ARRAY(int, rec->_classes_length);
+    for (int i = 0; i < rec->_classes_length; i++) {
+      int offset = parse_int("offset");
+      if (had_error()) {
+        return;
+      }
+      Klass* k = parse_klass(CHECK);
+      rec->_classes_offsets[i] = offset;
+      rec->_classes[i] = k;
+    }
+
+    if (!parse_tag_and_count("methods", rec->_methods_length)) {
+      return;
+    }
+    rec->_methods = NEW_RESOURCE_ARRAY(Method*, rec->_methods_length);
+    rec->_methods_offsets = NEW_RESOURCE_ARRAY(int, rec->_methods_length);
+    for (int i = 0; i < rec->_methods_length; i++) {
+      int offset = parse_int("offset");
+      if (had_error()) {
+        return;
+      }
+      Method* m = parse_method(CHECK);
+      rec->_methods_offsets[i] = offset;
+      rec->_methods[i] = m;
+    }
+  }
+
+  // instanceKlass <name>
+  //
+  // Loads and initializes the klass 'name'.  This can be used to
+  // create particular class loading environments
+  void process_instanceKlass(TRAPS) {
+    // just load the referenced class
+    Klass* k = parse_klass(CHECK);
+  }
+
+  // ciInstanceKlass <name> <is_linked> <is_initialized> <length> tag # # # ...
+  //
+  // Load the klass 'name' and link or initialize it.  Verify that the
+  // constant pool is the same length as 'length' and make sure the
+  // constant pool tags are in the same state.
+  void process_ciInstanceKlass(TRAPS) {
+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
+    int is_linked = parse_int("is_linked");
+    int is_initialized = parse_int("is_initialized");
+    int length = parse_int("length");
+    if (is_initialized) {
+      k->initialize(THREAD);
+      if (HAS_PENDING_EXCEPTION) {
+        oop throwable = PENDING_EXCEPTION;
+        java_lang_Throwable::print(throwable, tty);
+        tty->cr();
+        if (ciCacheProfiles::CacheIgnoreInitErrors) {
+          CLEAR_PENDING_EXCEPTION;
+          k->set_init_state(InstanceKlass::fully_initialized);
+        } else {
+          return;
+        }
+      }
+    } else if (is_linked) {
+      k->link_class(CHECK);
+    }
+    ConstantPool* cp = k->constants();
+    if (length != cp->length()) {
+      report_error("constant pool length mismatch: wrong class files?");
+      return;
+    }
+
+    int parsed_two_word = 0;
+    for (int i = 1; i < length; i++) {
+      int tag = parse_int("tag");
+      if (had_error()) {
+        return;
+      }
+      switch (cp->tag_at(i).value()) {
+        case JVM_CONSTANT_UnresolvedClass: {
+          if (tag == JVM_CONSTANT_Class) {
+            tty->print_cr("Resolving klass %s at %d", cp->klass_name_at(i)->as_utf8(), i);
+            Klass* k = cp->klass_at(i, CHECK);
+          }
+          break;
+        }
+        case JVM_CONSTANT_Long:
+        case JVM_CONSTANT_Double:
+          parsed_two_word = i + 1;
+
+        case JVM_CONSTANT_ClassIndex:
+        case JVM_CONSTANT_StringIndex:
+        case JVM_CONSTANT_String:
+        case JVM_CONSTANT_UnresolvedClassInError:
+        case JVM_CONSTANT_Fieldref:
+        case JVM_CONSTANT_Methodref:
+        case JVM_CONSTANT_InterfaceMethodref:
+        case JVM_CONSTANT_NameAndType:
+        case JVM_CONSTANT_Utf8:
+        case JVM_CONSTANT_Integer:
+        case JVM_CONSTANT_Float:
+        case JVM_CONSTANT_MethodHandle:
+        case JVM_CONSTANT_MethodType:
+        case JVM_CONSTANT_InvokeDynamic:
+          if (tag != cp->tag_at(i).value()) {
+            report_error("tag mismatch: wrong class files?");
+            return;
+          }
+          break;
+
+        case JVM_CONSTANT_Class:
+          if (tag == JVM_CONSTANT_Class) {
+          } else if (tag == JVM_CONSTANT_UnresolvedClass) {
+            tty->print_cr("Warning: entry was unresolved in the replay data");
+          } else {
+            report_error("Unexpected tag");
+            return;
+          }
+          break;
+
+        case 0:
+          if (parsed_two_word == i) continue;
+
+        default:
+          fatal("Unexpected tag: %d", cp->tag_at(i).value());
+          break;
+      }
+
+    }
+  }
+
+  // Initialize a class and fill in the value for a static field.
+  // This is useful when the compile was dependent on the value of
+  // static fields but it's impossible to properly rerun the static
+  // initiailizer.
+  void process_staticfield(TRAPS) {
+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
+
+    if (ReplaySuppressInitializers == 0 ||
+        ReplaySuppressInitializers == 2 && k->class_loader() == NULL) {
+      return;
+    }
+
+    assert(k->is_initialized(), "must be");
+
+    const char* field_name = parse_escaped_string();;
+    const char* field_signature = parse_string();
+    fieldDescriptor fd;
+    Symbol* name = SymbolTable::lookup(field_name, (int)strlen(field_name), CHECK);
+    Symbol* sig = SymbolTable::lookup(field_signature, (int)strlen(field_signature), CHECK);
+    if (!k->find_local_field(name, sig, &fd) ||
+        !fd.is_static() ||
+        fd.has_initial_value()) {
+      report_error(field_name);
+      return;
+    }
+
+    oop java_mirror = k->java_mirror();
+    if (field_signature[0] == '[') {
+      int length = parse_int("array length");
+      oop value = NULL;
+
+      if (field_signature[1] == '[') {
+        // multi dimensional array
+        ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
+        int rank = 0;
+        while (field_signature[rank] == '[') {
+          rank++;
+        }
+        int* dims = NEW_RESOURCE_ARRAY(int, rank);
+        dims[0] = length;
+        for (int i = 1; i < rank; i++) {
+          dims[i] = 1; // These aren't relevant to the compiler
+        }
+        value = kelem->multi_allocate(rank, dims, CHECK);
+      } else {
+        if (strcmp(field_signature, "[B") == 0) {
+          value = oopFactory::new_byteArray(length, CHECK);
+        } else if (strcmp(field_signature, "[Z") == 0) {
+          value = oopFactory::new_boolArray(length, CHECK);
+        } else if (strcmp(field_signature, "[C") == 0) {
+          value = oopFactory::new_charArray(length, CHECK);
+        } else if (strcmp(field_signature, "[S") == 0) {
+          value = oopFactory::new_shortArray(length, CHECK);
+        } else if (strcmp(field_signature, "[F") == 0) {
+          value = oopFactory::new_singleArray(length, CHECK);
+        } else if (strcmp(field_signature, "[D") == 0) {
+          value = oopFactory::new_doubleArray(length, CHECK);
+        } else if (strcmp(field_signature, "[I") == 0) {
+          value = oopFactory::new_intArray(length, CHECK);
+        } else if (strcmp(field_signature, "[J") == 0) {
+          value = oopFactory::new_longArray(length, CHECK);
+        } else if (field_signature[0] == '[' && field_signature[1] == 'L') {
+          KlassHandle kelem = resolve_klass(field_signature + 1, CHECK);
+          value = oopFactory::new_objArray(kelem(), length, CHECK);
+        } else {
+          report_error("unhandled array staticfield");
+        }
+      }
+      java_mirror->obj_field_put(fd.offset(), value);
+    } else {
+      const char* string_value = parse_escaped_string();
+      if (strcmp(field_signature, "I") == 0) {
+        int value = atoi(string_value);
+        java_mirror->int_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "B") == 0) {
+        int value = atoi(string_value);
+        java_mirror->byte_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "C") == 0) {
+        int value = atoi(string_value);
+        java_mirror->char_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "S") == 0) {
+        int value = atoi(string_value);
+        java_mirror->short_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "Z") == 0) {
+        int value = atol(string_value);
+        java_mirror->bool_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "J") == 0) {
+        jlong value;
+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {
+          fprintf(stderr, "Error parsing long: %s\n", string_value);
+          return;
+        }
+        java_mirror->long_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "F") == 0) {
+        float value = atof(string_value);
+        java_mirror->float_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "D") == 0) {
+        double value = atof(string_value);
+        java_mirror->double_field_put(fd.offset(), value);
+      } else if (strcmp(field_signature, "Ljava/lang/String;") == 0) {
+        Handle value = java_lang_String::create_from_str(string_value, CHECK);
+        java_mirror->obj_field_put(fd.offset(), value());
+      } else if (field_signature[0] == 'L') {
+        Symbol* klass_name = SymbolTable::lookup(field_signature, (int)strlen(field_signature), CHECK);
+        KlassHandle kelem = resolve_klass(field_signature, CHECK);
+        oop value = InstanceKlass::cast(kelem())->allocate_instance(CHECK);
+        java_mirror->obj_field_put(fd.offset(), value);
+      } else {
+        report_error("unhandled staticfield");
+      }
+    }
+  }
+
+#if INCLUDE_JVMTI
+  void process_JvmtiExport(TRAPS) {
+    const char* field = parse_string();
+    bool value = parse_int("JvmtiExport flag") != 0;
+    if (strcmp(field, "can_access_local_variables") == 0) {
+      JvmtiExport::set_can_access_local_variables(value);
+    } else if (strcmp(field, "can_hotswap_or_post_breakpoint") == 0) {
+      JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
+    } else if (strcmp(field, "can_post_on_exceptions") == 0) {
+      JvmtiExport::set_can_post_on_exceptions(value);
+    } else {
+      report_error("Unrecognized JvmtiExport directive");
+    }
+  }
+#endif // INCLUDE_JVMTI
+
+  // Create and initialize a record for a ciMethod
+  ciMethodRecord* new_ciMethod(Method* method) {
+    ciMethodRecord* rec = NEW_RESOURCE_OBJ(ciMethodRecord);
+    rec->_klass_name =  method->method_holder()->name()->as_utf8();
+    rec->_method_name = method->name()->as_utf8();
+    rec->_signature = method->signature()->as_utf8();
+    _ci_method_records.append(rec);
+    return rec;
+  }
+
+  // Lookup data for a ciMethod
+  ciMethodRecord* find_ciMethodRecord(Method* method) {
+    const char* klass_name =  method->method_holder()->name()->as_utf8();
+    const char* method_name = method->name()->as_utf8();
+    const char* signature = method->signature()->as_utf8();
+    for (int i = 0; i < _ci_method_records.length(); i++) {
+      ciMethodRecord* rec = _ci_method_records.at(i);
+      if (strcmp(rec->_klass_name, klass_name) == 0 &&
+          strcmp(rec->_method_name, method_name) == 0 &&
+          strcmp(rec->_signature, signature) == 0) {
+        return rec;
+      }
+    }
+    return NULL;
+  }
+
+  // Create and initialize a record for a ciMethodData
+  ciMethodDataRecord* new_ciMethodData(Method* method) {
+    ciMethodDataRecord* rec = NEW_RESOURCE_OBJ(ciMethodDataRecord);
+    rec->_klass_name =  method->method_holder()->name()->as_utf8();
+    rec->_method_name = method->name()->as_utf8();
+    rec->_signature = method->signature()->as_utf8();
+    _ci_method_data_records.append(rec);
+    return rec;
+  }
+
+  // Lookup data for a ciMethodData
+  ciMethodDataRecord* find_ciMethodDataRecord(Method* method) {
+    const char* klass_name =  method->method_holder()->name()->as_utf8();
+    const char* method_name = method->name()->as_utf8();
+    const char* signature = method->signature()->as_utf8();
+    for (int i = 0; i < _ci_method_data_records.length(); i++) {
+      ciMethodDataRecord* rec = _ci_method_data_records.at(i);
+      if (strcmp(rec->_klass_name, klass_name) == 0 &&
+          strcmp(rec->_method_name, method_name) == 0 &&
+          strcmp(rec->_signature, signature) == 0) {
+        return rec;
+      }
+    }
+    return NULL;
+  }
+
+  // Create and initialize a record for a ciInlineRecord
+  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {
+    ciInlineRecord* rec = NEW_RESOURCE_OBJ(ciInlineRecord);
+    rec->_klass_name =  method->method_holder()->name()->as_utf8();
+    rec->_method_name = method->name()->as_utf8();
+    rec->_signature = method->signature()->as_utf8();
+    rec->_inline_bci = bci;
+    rec->_inline_depth = depth;
+    _ci_inline_records->append(rec);
+    return rec;
+  }
+
+  // Lookup inlining data for a ciMethod
+  ciInlineRecord* find_ciInlineRecord(Method* method, int bci, int depth) {
+    if (_ci_inline_records != NULL) {
+      return find_ciInlineRecord(_ci_inline_records, method, bci, depth);
+    }
+    return NULL;
+  }
+
+  static ciInlineRecord* find_ciInlineRecord(GrowableArray<ciInlineRecord*>*  records,
+                                      Method* method, int bci, int depth) {
+    if (records != NULL) {
+      const char* klass_name  = method->method_holder()->name()->as_utf8();
+      const char* method_name = method->name()->as_utf8();
+      const char* signature   = method->signature()->as_utf8();
+      for (int i = 0; i < records->length(); i++) {
+        ciInlineRecord* rec = records->at(i);
+        if ((rec->_inline_bci == bci) &&
+            (rec->_inline_depth == depth) &&
+            (strcmp(rec->_klass_name, klass_name) == 0) &&
+            (strcmp(rec->_method_name, method_name) == 0) &&
+            (strcmp(rec->_signature, signature) == 0)) {
+          return rec;
+        }
+      }
+    }
+    return NULL;
+  }
+
+  const char* error_message() {
+    return _error_message;
+  }
+
+  void reset() {
+    _error_message = NULL;
+    _ci_method_records.clear();
+    _ci_method_data_records.clear();
+  }
+
+  // Take an ascii string contain \u#### escapes and convert it to utf8
+  // in place.
+  static void unescape_string(char* value) {
+    char* from = value;
+    char* to = value;
+    while (*from != '\0') {
+      if (*from != '\\') {
+        *from++ = *to++;
+      } else {
+        switch (from[1]) {
+          case 'u': {
+            from += 2;
+            jchar value=0;
+            for (int i=0; i<4; i++) {
+              char c = *from++;
+              switch (c) {
+                case '0': case '1': case '2': case '3': case '4':
+                case '5': case '6': case '7': case '8': case '9':
+                  value = (value << 4) + c - '0';
+                  break;
+                case 'a': case 'b': case 'c':
+                case 'd': case 'e': case 'f':
+                  value = (value << 4) + 10 + c - 'a';
+                  break;
+                case 'A': case 'B': case 'C':
+                case 'D': case 'E': case 'F':
+                  value = (value << 4) + 10 + c - 'A';
+                  break;
+                default:
+                  ShouldNotReachHere();
+              }
+            }
+            UNICODE::convert_to_utf8(&value, 1, to);
+            to++;
+            break;
+          }
+          case 't': *to++ = '\t'; from += 2; break;
+          case 'n': *to++ = '\n'; from += 2; break;
+          case 'r': *to++ = '\r'; from += 2; break;
+          case 'f': *to++ = '\f'; from += 2; break;
+          default:
+            ShouldNotReachHere();
+        }
+      }
+    }
+    *from = *to;
+  }
+};
+
+
+void ciCacheReplay::initialize(ciMethodData* m) {
+  if (replay_state == NULL) {
+    return;
+  }
+
+  ASSERT_IN_VM;
+  ResourceMark rm;
+
+  Method* method = m->get_MethodData()->method();
+  ciMethodDataRecord* rec = replay_state->find_ciMethodDataRecord(method);
+  if (rec == NULL) {
+    // This indicates some mismatch with the original environment and
+    // the replay environment though it's not always enough to
+    // interfere with reproducing a bug
+//    tty->print_cr("Warning: requesting ciMethodData record for method with no data: ");
+//    method->print_name(tty);
+//    tty->cr();
+  } else {
+    m->_state = rec->_state;
+    m->_current_mileage = rec->_current_mileage;
+    if (rec->_data_length != 0) {
+      assert(m->_data_size + m->_extra_data_size == rec->_data_length * (int)sizeof(rec->_data[0]) ||
+             m->_data_size == rec->_data_length * (int)sizeof(rec->_data[0]), "must agree");
+
+      // Write the correct ciObjects back into the profile data
+      ciEnv* env = ciEnv::current();
+      for (int i = 0; i < rec->_classes_length; i++) {
+        Klass *k = rec->_classes[i];
+        // In case this class pointer is is tagged, preserve the tag
+        // bits
+        rec->_data[rec->_classes_offsets[i]] =
+          ciTypeEntries::with_status(env->get_metadata(k)->as_klass(), rec->_data[rec->_classes_offsets[i]]);
+      }
+      for (int i = 0; i < rec->_methods_length; i++) {
+        Method *m = rec->_methods[i];
+        *(ciMetadata**)(rec->_data + rec->_methods_offsets[i]) =
+          env->get_metadata(m);
+      }
+      // Copy the updated profile data into place as intptr_ts
+#ifdef _LP64
+      Copy::conjoint_jlongs_atomic((jlong *)rec->_data, (jlong *)m->_data, rec->_data_length);
+#else
+      Copy::conjoint_jints_atomic((jint *)rec->_data, (jint *)m->_data, rec->_data_length);
+#endif
+    }
+
+    // copy in the original header
+    Copy::conjoint_jbytes(rec->_orig_data, (char*)&m->_orig, rec->_orig_data_length);
+  }
+}
+
+
+bool ciCacheReplay::should_not_inline(ciMethod* method) {
+  if (replay_state == NULL) {
+    return false;
+  }
+  VM_ENTRY_MARK;
+  // ciMethod without a record shouldn't be inlined.
+  return replay_state->find_ciMethodRecord(method->get_Method()) == NULL;
+}
+
+bool ciCacheReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {
+  if (data != NULL) {
+    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;
+    VM_ENTRY_MARK;
+    // Inline record are ordered by bci and depth.
+    return CacheCompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) != NULL;
+  } else if (replay_state != NULL) {
+    VM_ENTRY_MARK;
+    // Inline record are ordered by bci and depth.
+    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) != NULL;
+  }
+  return false;
+}
+
+bool ciCacheReplay::should_not_inline(void* data, ciMethod* method, int bci, int inline_depth) {
+  if (data != NULL) {
+    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;
+    VM_ENTRY_MARK;
+    // Inline record are ordered by bci and depth.
+    return CacheCompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) == NULL;
+  } else if (replay_state != NULL) {
+    VM_ENTRY_MARK;
+    // Inline record are ordered by bci and depth.
+    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) == NULL;
+  }
+  return false;
+}
+
+void ciCacheReplay::initialize(ciMethod* m) {
+  if (replay_state == NULL) {
+    return;
+  }
+
+  ASSERT_IN_VM;
+  ResourceMark rm;
+
+  Method* method = m->get_Method();
+  ciMethodRecord* rec = replay_state->find_ciMethodRecord(method);
+  if (rec == NULL) {
+    // This indicates some mismatch with the original environment and
+    // the replay environment though it's not always enough to
+    // interfere with reproducing a bug
+//    tty->print_cr("Warning: requesting ciMethod record for method with no data: ");
+//    method->print_name(tty);
+//    tty->cr();
+  } else {
+    EXCEPTION_CONTEXT;
+    // m->_instructions_size = rec->_instructions_size;
+    m->_instructions_size = -1;
+    m->_interpreter_invocation_count = rec->_interpreter_invocation_count;
+    m->_interpreter_throwout_count = rec->_interpreter_throwout_count;
+    MethodCounters* mcs = method->get_method_counters(CHECK_AND_CLEAR);
+    guarantee(mcs != NULL, "method counters allocation failed");
+    mcs->invocation_counter()->_counter = rec->_invocation_counter;
+    mcs->backedge_counter()->_counter = rec->_backedge_counter;
+  }
+}
+
+bool ciCacheReplay::is_loaded(Method* method) {
+  if (replay_state == NULL) {
+    return true;
+  }
+
+  ASSERT_IN_VM;
+  ResourceMark rm;
+
+  ciMethodRecord* rec = replay_state->find_ciMethodRecord(method);
+  return rec != NULL;
+}
+
+void ciCacheReplay::replay_cached(TRAPS, char* replay_data, int osr_bci, bool blocked) {
+	  HandleMark hm;
+	  ResourceMark rm;
+
+//    we can not use this code in release CONF
+//	  if (ReplaySuppressInitializers > 2) {
+//	    // ReplaySuppressInitializers > 2 means that we want to allow
+//	    // normal VM bootstrap but once we get into the replay itself
+//	    // don't allow any intializers to be run.
+//	    ReplaySuppressInitializers = 1;
+//	  }
+
+	  // Load and parse the replay data
+	  CacheCompileReplay rp(replay_data, THREAD, osr_bci, blocked);
+	  int exit_code = 0;
+	  if (rp.can_replay()) {
+		if(PrintCacheProfiles) {
+			tty->print_cr("Started processing replay file...");
+		}
+	    rp.process(THREAD);
+	  } else {
+	    exit_code = 1;
+		if(PrintCacheProfiles) {
+			tty->print_cr("Exit vm since we can not replay...");
+		}
+	    vm_exit(exit_code);
+	  }
+
+	  if (HAS_PENDING_EXCEPTION) {
+	    Handle throwable(THREAD, PENDING_EXCEPTION);
+	    CLEAR_PENDING_EXCEPTION;
+	    java_lang_Throwable::print_stack_trace(throwable, tty);
+	    tty->cr();
+	    exit_code = 2;
+	  }
+
+	  if (rp.had_error()) {
+	    tty->print_cr("Parsing failed on %s", rp.error_message());
+	    exit_code = 1;
+	  }
+	  // TODO: maybe do something with exit code?
+	  //return exit_code;
+}
+
+//#endif // PRODUCT
--- /dev/null	2016-08-11 14:11:23.983906000 +0200
+++ new/src/share/vm/ci/ciCacheReplay.hpp	2016-08-15 12:26:24.773019658 +0200
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_CI_CICACHEREPLAY_HPP
+#define SHARE_VM_CI_CICACHEREPLAY_HPP
+
+#include "ci/ciMethod.hpp"
+
+// ciReplay
+
+//
+// Replay compilation of a java method by using an information in replay file.
+// Replay inlining decisions during compilation by using an information in inline file.
+//
+// NOTE: these replay functions only exist in debug version of VM.
+//
+// Replay compilation.
+// -------------------
+//
+// Replay data file replay.txt can be created by Serviceability Agent
+// from a core file, see agent/doc/cireplay.html
+//
+// $ java -cp <jdk>/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB
+// hsdb> attach <jdk>/bin/java ./core
+// hsdb> threads
+// t@10 Service Thread
+// t@9 C2 CompilerThread0
+// t@8 Signal Dispatcher
+// t@7 Finalizer
+// t@6 Reference Handler
+// t@2 main
+// hsdb> dumpreplaydata t@9 > replay.txt
+// hsdb> quit
+//
+// (Note: SA could be also used to extract app.jar and boot.jar files
+//  from core file to replay compilation if only core file is available)
+//
+// Replay data file replay_pid%p.log is also created when VM crashes
+// in Compiler thread during compilation. It is controlled by
+// DumpReplayDataOnError flag which is ON by default.
+//
+// Replay file replay_pid%p_compid%d.log can be created
+// for the specified java method during normal execution using
+// CompileCommand option DumpReplay:
+//
+// -XX:CompileCommand=option,Benchmark::test,DumpReplay
+//
+// In this case the file name has additional compilation id "_compid%d"
+// because the method could be compiled several times.
+//
+// To replay compilation the replay file should be specified:
+//
+// -XX:+ReplayCompiles -XX:ReplayDataFile=replay_pid2133.log
+//
+// VM thread reads data from the file immediately after VM initialization
+// and puts the compilation task on compile queue. After that it goes into
+// wait state (BackgroundCompilation flag is set to false) since there is no
+// a program to execute. VM exits when the compilation is finished.
+//
+//
+// Replay inlining.
+// ----------------
+//
+// Replay inlining file inline_pid%p_compid%d.log is created for
+// a specific java method during normal execution of a java program
+// using CompileCommand option DumpInline:
+//
+// -XX:CompileCommand=option,Benchmark::test,DumpInline
+//
+// To replay inlining the replay file and the method should be specified:
+//
+// -XX:CompileCommand=option,Benchmark::test,ReplayInline -XX:InlineDataFile=inline_pid3244_compid6.log
+//
+// The difference from replay compilation is that replay inlining
+// is performed during normal java program execution.
+//
+
+class ciCacheReplay {
+  CI_PACKAGE_ACCESS
+
+//#ifndef PRODUCT
+ private:
+
+ public:
+  // Replay specified cached compilation and do NOT exit VM.
+  static void replay_cached(TRAPS, char* replay_data, int osr_bci, bool blocked);
+  // Load inlining decisions from file and use them
+  // during compilation of specified method.
+  static void* load_inline_data(ciMethod* method, int entry_bci, int comp_level);
+
+  // These are used by the CI to fill in the cached data from the
+  // replay file when replaying compiles.
+  static void initialize(ciMethodData* method);
+  static void initialize(ciMethod* method);
+
+  static bool is_loaded(Method* method);
+  static bool is_loaded(Klass* klass);
+
+  static bool should_not_inline(ciMethod* method);
+  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth);
+  static bool should_not_inline(void* data, ciMethod* method, int bci, int inline_depth);
+
+//#endif
+};
+
+#endif // SHARE_VM_CI_CICACHEREPLAY_HPP
