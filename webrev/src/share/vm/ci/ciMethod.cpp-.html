<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/ci/ciMethod.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "ci/ciCallProfile.hpp"
  27 #include "ci/ciExceptionHandler.hpp"
  28 #include "ci/ciInstanceKlass.hpp"
  29 #include "ci/ciMethod.hpp"
  30 #include "ci/ciMethodBlocks.hpp"
  31 #include "ci/ciMethodData.hpp"
  32 #include "ci/ciStreams.hpp"
  33 #include "ci/ciSymbol.hpp"
  34 #include "ci/ciReplay.hpp"
  35 #include "ci/ciUtilities.hpp"
  36 #include "classfile/systemDictionary.hpp"
  37 #include "compiler/abstractCompiler.hpp"
  38 #include "compiler/methodLiveness.hpp"
  39 #include "interpreter/interpreter.hpp"
  40 #include "interpreter/linkResolver.hpp"
  41 #include "interpreter/oopMapCache.hpp"
  42 #include "memory/allocation.inline.hpp"
  43 #include "memory/resourceArea.hpp"
  44 #include "oops/generateOopMap.hpp"
  45 #include "oops/oop.inline.hpp"
  46 #include "prims/nativeLookup.hpp"
  47 #include "runtime/deoptimization.hpp"
  48 #include "utilities/bitMap.inline.hpp"
  49 #include "utilities/xmlstream.hpp"
  50 #include "trace/tracing.hpp"
  51 #ifdef COMPILER2
  52 #include "ci/bcEscapeAnalyzer.hpp"
  53 #include "ci/ciTypeFlow.hpp"
  54 #include "oops/method.hpp"
  55 #endif
  56 #ifdef SHARK
  57 #include "ci/ciTypeFlow.hpp"
  58 #include "oops/method.hpp"
  59 #endif
  60 
  61 // ciMethod
  62 //
  63 // This class represents a Method* in the HotSpot virtual
  64 // machine.
  65 
  66 
  67 // ------------------------------------------------------------------
  68 // ciMethod::ciMethod
  69 //
  70 // Loaded method.
  71 ciMethod::ciMethod(methodHandle h_m, ciInstanceKlass* holder) :
  72   ciMetadata(h_m()),
  73   _holder(holder)
  74 {
  75   assert(h_m() != NULL, "no null method");
  76 
  77   if (LogTouchedMethods) {
  78     h_m()-&gt;log_touched(Thread::current());
  79   }
  80   // These fields are always filled in in loaded methods.
  81   _flags = ciFlags(h_m()-&gt;access_flags());
  82 
  83   // Easy to compute, so fill them in now.
  84   _max_stack          = h_m()-&gt;max_stack();
  85   _max_locals         = h_m()-&gt;max_locals();
  86   _code_size          = h_m()-&gt;code_size();
  87   _intrinsic_id       = h_m()-&gt;intrinsic_id();
  88   _handler_count      = h_m()-&gt;exception_table_length();
  89   _size_of_parameters = h_m()-&gt;size_of_parameters();
  90   _uses_monitors      = h_m()-&gt;access_flags().has_monitor_bytecodes();
  91   _balanced_monitors  = !_uses_monitors || h_m()-&gt;access_flags().is_monitor_matching();
  92   _is_c1_compilable   = !h_m()-&gt;is_not_c1_compilable();
  93   _is_c2_compilable   = !h_m()-&gt;is_not_c2_compilable();
  94   _has_reserved_stack_access = h_m()-&gt;has_reserved_stack_access();
  95   // Lazy fields, filled in on demand.  Require allocation.
  96   _code               = NULL;
  97   _exception_handlers = NULL;
  98   _liveness           = NULL;
  99   _method_blocks = NULL;
 100 #if defined(COMPILER2) || defined(SHARK)
 101   _flow               = NULL;
 102   _bcea               = NULL;
 103 #endif // COMPILER2 || SHARK
 104 
 105   ciEnv *env = CURRENT_ENV;
 106   if (env-&gt;jvmti_can_hotswap_or_post_breakpoint() &amp;&amp; can_be_compiled()) {
 107     // 6328518 check hotswap conditions under the right lock.
 108     MutexLocker locker(Compile_lock);
 109     if (Dependencies::check_evol_method(h_m()) != NULL) {
 110       _is_c1_compilable = false;
 111       _is_c2_compilable = false;
 112     }
 113   } else {
 114     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
 115   }
 116 
 117   if (h_m()-&gt;method_holder()-&gt;is_linked()) {
 118     _can_be_statically_bound = h_m()-&gt;can_be_statically_bound();
 119   } else {
 120     // Have to use a conservative value in this case.
 121     _can_be_statically_bound = false;
 122   }
 123 
 124   // Adjust the definition of this condition to be more useful:
 125   // %%% take these conditions into account in vtable generation
 126   if (!_can_be_statically_bound &amp;&amp; h_m()-&gt;is_private())
 127     _can_be_statically_bound = true;
 128   if (_can_be_statically_bound &amp;&amp; h_m()-&gt;is_abstract())
 129     _can_be_statically_bound = false;
 130 
 131   // generating _signature may allow GC and therefore move m.
 132   // These fields are always filled in.
 133   _name = env-&gt;get_symbol(h_m()-&gt;name());
 134   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m()-&gt;signature());
 135   constantPoolHandle cpool = h_m()-&gt;constants();
 136   _signature = new (env-&gt;arena()) ciSignature(_holder, cpool, sig_symbol);
 137   _method_data = NULL;
 138   _nmethod_age = h_m()-&gt;nmethod_age();
 139   // Take a snapshot of these values, so they will be commensurate with the MDO.
 140   if (ProfileInterpreter || TieredCompilation) {
 141     int invcnt = h_m()-&gt;interpreter_invocation_count();
 142     // if the value overflowed report it as max int
 143     _interpreter_invocation_count = invcnt &lt; 0 ? max_jint : invcnt ;
 144     _interpreter_throwout_count   = h_m()-&gt;interpreter_throwout_count();
 145   } else {
 146     _interpreter_invocation_count = 0;
 147     _interpreter_throwout_count = 0;
 148   }
 149   if (_interpreter_invocation_count == 0)
 150     _interpreter_invocation_count = 1;
 151   _instructions_size = -1;
 152 #ifdef ASSERT
 153   if (ReplayCompiles) {
 154     ciReplay::initialize(this);
 155   }
 156 #endif
 157 }
 158 
 159 
 160 // ------------------------------------------------------------------
 161 // ciMethod::ciMethod
 162 //
 163 // Unloaded method.
 164 ciMethod::ciMethod(ciInstanceKlass* holder,
 165                    ciSymbol*        name,
 166                    ciSymbol*        signature,
 167                    ciInstanceKlass* accessor) :
 168   ciMetadata((Metadata*)NULL),
 169   _name(                   name),
 170   _holder(                 holder),
 171   _intrinsic_id(           vmIntrinsics::_none),
 172   _liveness(               NULL),
 173   _can_be_statically_bound(false),
 174   _method_blocks(          NULL),
 175   _method_data(            NULL)
 176 #if defined(COMPILER2) || defined(SHARK)
 177   ,
 178   _flow(                   NULL),
 179   _bcea(                   NULL),
 180   _instructions_size(-1)
 181 #endif // COMPILER2 || SHARK
 182 {
 183   // Usually holder and accessor are the same type but in some cases
 184   // the holder has the wrong class loader (e.g. invokedynamic call
 185   // sites) so we pass the accessor.
 186   _signature = new (CURRENT_ENV-&gt;arena()) ciSignature(accessor, constantPoolHandle(), signature);
 187 }
 188 
 189 
 190 // ------------------------------------------------------------------
 191 // ciMethod::load_code
 192 //
 193 // Load the bytecodes and exception handler table for this method.
 194 void ciMethod::load_code() {
 195   VM_ENTRY_MARK;
 196   assert(is_loaded(), "only loaded methods have code");
 197 
 198   Method* me = get_Method();
 199   Arena* arena = CURRENT_THREAD_ENV-&gt;arena();
 200 
 201   // Load the bytecodes.
 202   _code = (address)arena-&gt;Amalloc(code_size());
 203   memcpy(_code, me-&gt;code_base(), code_size());
 204 
 205   // Revert any breakpoint bytecodes in ci's copy
 206   if (me-&gt;number_of_breakpoints() &gt; 0) {
 207     BreakpointInfo* bp = me-&gt;method_holder()-&gt;breakpoints();
 208     for (; bp != NULL; bp = bp-&gt;next()) {
 209       if (bp-&gt;match(me)) {
 210         code_at_put(bp-&gt;bci(), bp-&gt;orig_bytecode());
 211       }
 212     }
 213   }
 214 
 215   // And load the exception table.
 216   ExceptionTable exc_table(me);
 217 
 218   // Allocate one extra spot in our list of exceptions.  This
 219   // last entry will be used to represent the possibility that
 220   // an exception escapes the method.  See ciExceptionHandlerStream
 221   // for details.
 222   _exception_handlers =
 223     (ciExceptionHandler**)arena-&gt;Amalloc(sizeof(ciExceptionHandler*)
 224                                          * (_handler_count + 1));
 225   if (_handler_count &gt; 0) {
 226     for (int i=0; i&lt;_handler_count; i++) {
 227       _exception_handlers[i] = new (arena) ciExceptionHandler(
 228                                 holder(),
 229             /* start    */      exc_table.start_pc(i),
 230             /* limit    */      exc_table.end_pc(i),
 231             /* goto pc  */      exc_table.handler_pc(i),
 232             /* cp index */      exc_table.catch_type_index(i));
 233     }
 234   }
 235 
 236   // Put an entry at the end of our list to represent the possibility
 237   // of exceptional exit.
 238   _exception_handlers[_handler_count] =
 239     new (arena) ciExceptionHandler(holder(), 0, code_size(), -1, 0);
 240 
 241   if (CIPrintMethodCodes) {
 242     print_codes();
 243   }
 244 }
 245 
 246 
 247 // ------------------------------------------------------------------
 248 // ciMethod::has_linenumber_table
 249 //
 250 // length unknown until decompression
 251 bool    ciMethod::has_linenumber_table() const {
 252   check_is_loaded();
 253   VM_ENTRY_MARK;
 254   return get_Method()-&gt;has_linenumber_table();
 255 }
 256 
 257 
 258 // ------------------------------------------------------------------
 259 // ciMethod::compressed_linenumber_table
 260 u_char* ciMethod::compressed_linenumber_table() const {
 261   check_is_loaded();
 262   VM_ENTRY_MARK;
 263   return get_Method()-&gt;compressed_linenumber_table();
 264 }
 265 
 266 
 267 // ------------------------------------------------------------------
 268 // ciMethod::line_number_from_bci
 269 int ciMethod::line_number_from_bci(int bci) const {
 270   check_is_loaded();
 271   VM_ENTRY_MARK;
 272   return get_Method()-&gt;line_number_from_bci(bci);
 273 }
 274 
 275 
 276 // ------------------------------------------------------------------
 277 // ciMethod::vtable_index
 278 //
 279 // Get the position of this method's entry in the vtable, if any.
 280 int ciMethod::vtable_index() {
 281   check_is_loaded();
 282   assert(holder()-&gt;is_linked(), "must be linked");
 283   VM_ENTRY_MARK;
 284   return get_Method()-&gt;vtable_index();
 285 }
 286 
 287 
 288 #ifdef SHARK
 289 // ------------------------------------------------------------------
 290 // ciMethod::itable_index
 291 //
 292 // Get the position of this method's entry in the itable, if any.
 293 int ciMethod::itable_index() {
 294   check_is_loaded();
 295   assert(holder()-&gt;is_linked(), "must be linked");
 296   VM_ENTRY_MARK;
 297   Method* m = get_Method();
 298   if (!m-&gt;has_itable_index())
 299     return Method::nonvirtual_vtable_index;
 300   return m-&gt;itable_index();
 301 }
 302 #endif // SHARK
 303 
 304 
 305 // ------------------------------------------------------------------
 306 // ciMethod::native_entry
 307 //
 308 // Get the address of this method's native code, if any.
 309 address ciMethod::native_entry() {
 310   check_is_loaded();
 311   assert(flags().is_native(), "must be native method");
 312   VM_ENTRY_MARK;
 313   Method* method = get_Method();
 314   address entry = method-&gt;native_function();
 315   assert(entry != NULL, "must be valid entry point");
 316   return entry;
 317 }
 318 
 319 
 320 // ------------------------------------------------------------------
 321 // ciMethod::interpreter_entry
 322 //
 323 // Get the entry point for running this method in the interpreter.
 324 address ciMethod::interpreter_entry() {
 325   check_is_loaded();
 326   VM_ENTRY_MARK;
 327   methodHandle mh(THREAD, get_Method());
 328   return Interpreter::entry_for_method(mh);
 329 }
 330 
 331 
 332 // ------------------------------------------------------------------
 333 // ciMethod::uses_balanced_monitors
 334 //
 335 // Does this method use monitors in a strict stack-disciplined manner?
 336 bool ciMethod::has_balanced_monitors() {
 337   check_is_loaded();
 338   if (_balanced_monitors) return true;
 339 
 340   // Analyze the method to see if monitors are used properly.
 341   VM_ENTRY_MARK;
 342   methodHandle method(THREAD, get_Method());
 343   assert(method-&gt;has_monitor_bytecodes(), "should have checked this");
 344 
 345   // Check to see if a previous compilation computed the
 346   // monitor-matching analysis.
 347   if (method-&gt;guaranteed_monitor_matching()) {
 348     _balanced_monitors = true;
 349     return true;
 350   }
 351 
 352   {
 353     EXCEPTION_MARK;
 354     ResourceMark rm(THREAD);
 355     GeneratePairingInfo gpi(method);
 356     gpi.compute_map(CATCH);
 357     if (!gpi.monitor_safe()) {
 358       return false;
 359     }
 360     method-&gt;set_guaranteed_monitor_matching();
 361     _balanced_monitors = true;
 362   }
 363   return true;
 364 }
 365 
 366 
 367 // ------------------------------------------------------------------
 368 // ciMethod::get_flow_analysis
 369 ciTypeFlow* ciMethod::get_flow_analysis() {
 370 #if defined(COMPILER2) || defined(SHARK)
 371   if (_flow == NULL) {
 372     ciEnv* env = CURRENT_ENV;
 373     _flow = new (env-&gt;arena()) ciTypeFlow(env, this);
 374     _flow-&gt;do_flow();
 375   }
 376   return _flow;
 377 #else // COMPILER2 || SHARK
 378   ShouldNotReachHere();
 379   return NULL;
 380 #endif // COMPILER2 || SHARK
 381 }
 382 
 383 
 384 // ------------------------------------------------------------------
 385 // ciMethod::get_osr_flow_analysis
 386 ciTypeFlow* ciMethod::get_osr_flow_analysis(int osr_bci) {
 387 #if defined(COMPILER2) || defined(SHARK)
 388   // OSR entry points are always place after a call bytecode of some sort
 389   assert(osr_bci &gt;= 0, "must supply valid OSR entry point");
 390   ciEnv* env = CURRENT_ENV;
 391   ciTypeFlow* flow = new (env-&gt;arena()) ciTypeFlow(env, this, osr_bci);
 392   flow-&gt;do_flow();
 393   return flow;
 394 #else // COMPILER2 || SHARK
 395   ShouldNotReachHere();
 396   return NULL;
 397 #endif // COMPILER2 || SHARK
 398 }
 399 
 400 // ------------------------------------------------------------------
 401 // ciMethod::raw_liveness_at_bci
 402 //
 403 // Which local variables are live at a specific bci?
 404 MethodLivenessResult ciMethod::raw_liveness_at_bci(int bci) {
 405   check_is_loaded();
 406   if (_liveness == NULL) {
 407     // Create the liveness analyzer.
 408     Arena* arena = CURRENT_ENV-&gt;arena();
 409     _liveness = new (arena) MethodLiveness(arena, this);
 410     _liveness-&gt;compute_liveness();
 411   }
 412   return _liveness-&gt;get_liveness_at(bci);
 413 }
 414 
 415 // ------------------------------------------------------------------
 416 // ciMethod::liveness_at_bci
 417 //
 418 // Which local variables are live at a specific bci?  When debugging
 419 // will return true for all locals in some cases to improve debug
 420 // information.
 421 MethodLivenessResult ciMethod::liveness_at_bci(int bci) {
 422   MethodLivenessResult result = raw_liveness_at_bci(bci);
 423   if (CURRENT_ENV-&gt;should_retain_local_variables() || DeoptimizeALot || CompileTheWorld) {
 424     // Keep all locals live for the user's edification and amusement.
 425     result.at_put_range(0, result.size(), true);
 426   }
 427   return result;
 428 }
 429 
 430 // ciMethod::live_local_oops_at_bci
 431 //
 432 // find all the live oops in the locals array for a particular bci
 433 // Compute what the interpreter believes by using the interpreter
 434 // oopmap generator. This is used as a double check during osr to
 435 // guard against conservative result from MethodLiveness making us
 436 // think a dead oop is live.  MethodLiveness is conservative in the
 437 // sense that it may consider locals to be live which cannot be live,
 438 // like in the case where a local could contain an oop or  a primitive
 439 // along different paths.  In that case the local must be dead when
 440 // those paths merge. Since the interpreter's viewpoint is used when
 441 // gc'ing an interpreter frame we need to use its viewpoint  during
 442 // OSR when loading the locals.
 443 
 444 BitMap ciMethod::live_local_oops_at_bci(int bci) {
 445   VM_ENTRY_MARK;
 446   InterpreterOopMap mask;
 447   OopMapCache::compute_one_oop_map(get_Method(), bci, &amp;mask);
 448   int mask_size = max_locals();
 449   BitMap result(mask_size);
 450   result.clear();
 451   int i;
 452   for (i = 0; i &lt; mask_size ; i++ ) {
 453     if (mask.is_oop(i)) result.set_bit(i);
 454   }
 455   return result;
 456 }
 457 
 458 
 459 #ifdef COMPILER1
 460 // ------------------------------------------------------------------
 461 // ciMethod::bci_block_start
 462 //
 463 // Marks all bcis where a new basic block starts
 464 const BitMap ciMethod::bci_block_start() {
 465   check_is_loaded();
 466   if (_liveness == NULL) {
 467     // Create the liveness analyzer.
 468     Arena* arena = CURRENT_ENV-&gt;arena();
 469     _liveness = new (arena) MethodLiveness(arena, this);
 470     _liveness-&gt;compute_liveness();
 471   }
 472 
 473   return _liveness-&gt;get_bci_block_start();
 474 }
 475 #endif // COMPILER1
 476 
 477 
 478 // ------------------------------------------------------------------
 479 // ciMethod::call_profile_at_bci
 480 //
 481 // Get the ciCallProfile for the invocation of this method.
 482 // Also reports receiver types for non-call type checks (if TypeProfileCasts).
 483 ciCallProfile ciMethod::call_profile_at_bci(int bci) {
 484   ResourceMark rm;
 485   ciCallProfile result;
 486   if (method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 487     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 488     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 489       // Every profiled call site has a counter.
 490       int count = data-&gt;as_CounterData()-&gt;count();
 491 
 492       if (!data-&gt;is_ReceiverTypeData()) {
 493         result._receiver_count[0] = 0;  // that's a definite zero
 494       } else { // ReceiverTypeData is a subclass of CounterData
 495         ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
 496         // In addition, virtual call sites have receiver type information
 497         int receivers_count_total = 0;
 498         int morphism = 0;
 499         // Precompute morphism for the possible fixup
 500         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 501           ciKlass* receiver = call-&gt;receiver(i);
 502           if (receiver == NULL)  continue;
 503           morphism++;
 504         }
 505         int epsilon = 0;
 506         if (TieredCompilation &amp;&amp; ProfileInterpreter) {
 507           // Interpreter and C1 treat final and special invokes differently.
 508           // C1 will record a type, whereas the interpreter will just
 509           // increment the count. Detect this case.
 510           if (morphism == 1 &amp;&amp; count &gt; 0) {
 511             epsilon = count;
 512             count = 0;
 513           }
 514         }
 515         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 516           ciKlass* receiver = call-&gt;receiver(i);
 517           if (receiver == NULL)  continue;
 518           int rcount = call-&gt;receiver_count(i) + epsilon;
 519           if (rcount == 0) rcount = 1; // Should be valid value
 520           receivers_count_total += rcount;
 521           // Add the receiver to result data.
 522           result.add_receiver(receiver, rcount);
 523           // If we extend profiling to record methods,
 524           // we will set result._method also.
 525         }
 526         // Determine call site's morphism.
 527         // The call site count is 0 with known morphism (onlt 1 or 2 receivers)
 528         // or &lt; 0 in the case of a type check failured for checkcast, aastore, instanceof.
 529         // The call site count is &gt; 0 in the case of a polymorphic virtual call.
 530         if (morphism &gt; 0 &amp;&amp; morphism == result._limit) {
 531            // The morphism &lt;= MorphismLimit.
 532            if ((morphism &lt;  ciCallProfile::MorphismLimit) ||
 533                (morphism == ciCallProfile::MorphismLimit &amp;&amp; count == 0)) {
 534 #ifdef ASSERT
 535              if (count &gt; 0) {
 536                this-&gt;print_short_name(tty);
 537                tty-&gt;print_cr(" @ bci:%d", bci);
 538                this-&gt;print_codes();
 539                assert(false, "this call site should not be polymorphic");
 540              }
 541 #endif
 542              result._morphism = morphism;
 543            }
 544         }
 545         // Make the count consistent if this is a call profile. If count is
 546         // zero or less, presume that this is a typecheck profile and
 547         // do nothing.  Otherwise, increase count to be the sum of all
 548         // receiver's counts.
 549         if (count &gt;= 0) {
 550           count += receivers_count_total;
 551         }
 552       }
 553       result._count = count;
 554     }
 555   }
 556   return result;
 557 }
 558 
 559 // ------------------------------------------------------------------
 560 // Add new receiver and sort data by receiver's profile count.
 561 void ciCallProfile::add_receiver(ciKlass* receiver, int receiver_count) {
 562   // Add new receiver and sort data by receiver's counts when we have space
 563   // for it otherwise replace the less called receiver (less called receiver
 564   // is placed to the last array element which is not used).
 565   // First array's element contains most called receiver.
 566   int i = _limit;
 567   for (; i &gt; 0 &amp;&amp; receiver_count &gt; _receiver_count[i-1]; i--) {
 568     _receiver[i] = _receiver[i-1];
 569     _receiver_count[i] = _receiver_count[i-1];
 570   }
 571   _receiver[i] = receiver;
 572   _receiver_count[i] = receiver_count;
 573   if (_limit &lt; MorphismLimit) _limit++;
 574 }
 575 
 576 
 577 void ciMethod::assert_virtual_call_type_ok(int bci) {
 578   assert(java_code_at_bci(bci) == Bytecodes::_invokevirtual ||
 579          java_code_at_bci(bci) == Bytecodes::_invokeinterface, "unexpected bytecode %s", Bytecodes::name(java_code_at_bci(bci)));
 580 }
 581 
 582 void ciMethod::assert_call_type_ok(int bci) {
 583   assert(java_code_at_bci(bci) == Bytecodes::_invokestatic ||
 584          java_code_at_bci(bci) == Bytecodes::_invokespecial ||
 585          java_code_at_bci(bci) == Bytecodes::_invokedynamic, "unexpected bytecode %s", Bytecodes::name(java_code_at_bci(bci)));
 586 }
 587 
 588 /**
 589  * Check whether profiling provides a type for the argument i to the
 590  * call at bci bci
 591  *
 592  * @param [in]bci         bci of the call
 593  * @param [in]i           argument number
 594  * @param [out]type       profiled type of argument, NULL if none
 595  * @param [out]maybe_null true if null was seen for argument
 596  * @return                true if profiling exists
 597  *
 598  */
 599 bool ciMethod::argument_profiled_type(int bci, int i, ciKlass*&amp; type, bool&amp; maybe_null) {
 600   if (MethodData::profile_parameters() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 601     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 602     if (data != NULL) {
 603       if (data-&gt;is_VirtualCallTypeData()) {
 604         assert_virtual_call_type_ok(bci);
 605         ciVirtualCallTypeData* call = (ciVirtualCallTypeData*)data-&gt;as_VirtualCallTypeData();
 606         if (i &gt;= call-&gt;number_of_arguments()) {
 607           return false;
 608         }
 609         type = call-&gt;valid_argument_type(i);
 610         maybe_null = call-&gt;argument_maybe_null(i);
 611         return true;
 612       } else if (data-&gt;is_CallTypeData()) {
 613         assert_call_type_ok(bci);
 614         ciCallTypeData* call = (ciCallTypeData*)data-&gt;as_CallTypeData();
 615         if (i &gt;= call-&gt;number_of_arguments()) {
 616           return false;
 617         }
 618         type = call-&gt;valid_argument_type(i);
 619         maybe_null = call-&gt;argument_maybe_null(i);
 620         return true;
 621       }
 622     }
 623   }
 624   return false;
 625 }
 626 
 627 /**
 628  * Check whether profiling provides a type for the return value from
 629  * the call at bci bci
 630  *
 631  * @param [in]bci         bci of the call
 632  * @param [out]type       profiled type of argument, NULL if none
 633  * @param [out]maybe_null true if null was seen for argument
 634  * @return                true if profiling exists
 635  *
 636  */
 637 bool ciMethod::return_profiled_type(int bci, ciKlass*&amp; type, bool&amp; maybe_null) {
 638   if (MethodData::profile_return() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 639     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 640     if (data != NULL) {
 641       if (data-&gt;is_VirtualCallTypeData()) {
 642         assert_virtual_call_type_ok(bci);
 643         ciVirtualCallTypeData* call = (ciVirtualCallTypeData*)data-&gt;as_VirtualCallTypeData();
 644         type = call-&gt;valid_return_type();
 645         maybe_null = call-&gt;return_maybe_null();
 646         return true;
 647       } else if (data-&gt;is_CallTypeData()) {
 648         assert_call_type_ok(bci);
 649         ciCallTypeData* call = (ciCallTypeData*)data-&gt;as_CallTypeData();
 650         type = call-&gt;valid_return_type();
 651         maybe_null = call-&gt;return_maybe_null();
 652         return true;
 653       }
 654     }
 655   }
 656   return false;
 657 }
 658 
 659 /**
 660  * Check whether profiling provides a type for the parameter i
 661  *
 662  * @param [in]i           parameter number
 663  * @param [out]type       profiled type of parameter, NULL if none
 664  * @param [out]maybe_null true if null was seen for parameter
 665  * @return                true if profiling exists
 666  *
 667  */
 668 bool ciMethod::parameter_profiled_type(int i, ciKlass*&amp; type, bool&amp; maybe_null) {
 669   if (MethodData::profile_parameters() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 670     ciParametersTypeData* parameters = method_data()-&gt;parameters_type_data();
 671     if (parameters != NULL &amp;&amp; i &lt; parameters-&gt;number_of_parameters()) {
 672       type = parameters-&gt;valid_parameter_type(i);
 673       maybe_null = parameters-&gt;parameter_maybe_null(i);
 674       return true;
 675     }
 676   }
 677   return false;
 678 }
 679 
 680 
 681 // ------------------------------------------------------------------
 682 // ciMethod::find_monomorphic_target
 683 //
 684 // Given a certain calling environment, find the monomorphic target
 685 // for the call.  Return NULL if the call is not monomorphic in
 686 // its calling environment, or if there are only abstract methods.
 687 // The returned method is never abstract.
 688 // Note: If caller uses a non-null result, it must inform dependencies
 689 // via assert_unique_concrete_method or assert_leaf_type.
 690 ciMethod* ciMethod::find_monomorphic_target(ciInstanceKlass* caller,
 691                                             ciInstanceKlass* callee_holder,
 692                                             ciInstanceKlass* actual_recv,
 693                                             bool check_access) {
 694   check_is_loaded();
 695 
 696   if (actual_recv-&gt;is_interface()) {
 697     // %%% We cannot trust interface types, yet.  See bug 6312651.
 698     return NULL;
 699   }
 700 
 701   ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access);
 702   if (root_m == NULL) {
 703     // Something went wrong looking up the actual receiver method.
 704     return NULL;
 705   }
 706   assert(!root_m-&gt;is_abstract(), "resolve_invoke promise");
 707 
 708   // Make certain quick checks even if UseCHA is false.
 709 
 710   // Is it private or final?
 711   if (root_m-&gt;can_be_statically_bound()) {
 712     return root_m;
 713   }
 714 
 715   if (actual_recv-&gt;is_leaf_type() &amp;&amp; actual_recv == root_m-&gt;holder()) {
 716     // Easy case.  There is no other place to put a method, so don't bother
 717     // to go through the VM_ENTRY_MARK and all the rest.
 718     return root_m;
 719   }
 720 
 721   // Array methods (clone, hashCode, etc.) are always statically bound.
 722   // If we were to see an array type here, we'd return root_m.
 723   // However, this method processes only ciInstanceKlasses.  (See 4962591.)
 724   // The inline_native_clone intrinsic narrows Object to T[] properly,
 725   // so there is no need to do the same job here.
 726 
 727   if (!UseCHA)  return NULL;
 728 
 729   VM_ENTRY_MARK;
 730 
 731   // Disable CHA for default methods for now
 732   if (root_m-&gt;get_Method()-&gt;is_default_method()) {
 733     return NULL;
 734   }
 735 
 736   methodHandle target;
 737   {
 738     MutexLocker locker(Compile_lock);
 739     Klass* context = actual_recv-&gt;get_Klass();
 740     target = Dependencies::find_unique_concrete_method(context,
 741                                                        root_m-&gt;get_Method());
 742     // %%% Should upgrade this ciMethod API to look for 1 or 2 concrete methods.
 743   }
 744 
 745 #ifndef PRODUCT
 746   if (TraceDependencies &amp;&amp; target() != NULL &amp;&amp; target() != root_m-&gt;get_Method()) {
 747     tty-&gt;print("found a non-root unique target method");
 748     tty-&gt;print_cr("  context = %s", actual_recv-&gt;get_Klass()-&gt;external_name());
 749     tty-&gt;print("  method  = ");
 750     target-&gt;print_short_name(tty);
 751     tty-&gt;cr();
 752   }
 753 #endif //PRODUCT
 754 
 755   if (target() == NULL) {
 756     return NULL;
 757   }
 758   if (target() == root_m-&gt;get_Method()) {
 759     return root_m;
 760   }
 761   if (!root_m-&gt;is_public() &amp;&amp;
 762       !root_m-&gt;is_protected()) {
 763     // If we are going to reason about inheritance, it's easiest
 764     // if the method in question is public, protected, or private.
 765     // If the answer is not root_m, it is conservatively correct
 766     // to return NULL, even if the CHA encountered irrelevant
 767     // methods in other packages.
 768     // %%% TO DO: Work out logic for package-private methods
 769     // with the same name but different vtable indexes.
 770     return NULL;
 771   }
 772   return CURRENT_THREAD_ENV-&gt;get_method(target());
 773 }
 774 
 775 // ------------------------------------------------------------------
 776 // ciMethod::resolve_invoke
 777 //
 778 // Given a known receiver klass, find the target for the call.
 779 // Return NULL if the call has no target or the target is abstract.
 780 ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {
 781    check_is_loaded();
 782    VM_ENTRY_MARK;
 783 
 784    KlassHandle caller_klass (THREAD, caller-&gt;get_Klass());
 785    KlassHandle h_recv       (THREAD, exact_receiver-&gt;get_Klass());
 786    KlassHandle h_resolved   (THREAD, holder()-&gt;get_Klass());
 787    Symbol* h_name      = name()-&gt;get_symbol();
 788    Symbol* h_signature = signature()-&gt;get_symbol();
 789 
 790    LinkInfo link_info(h_resolved, h_name, h_signature, caller_klass, check_access);
 791    methodHandle m;
 792    // Only do exact lookup if receiver klass has been linked.  Otherwise,
 793    // the vtable has not been setup, and the LinkResolver will fail.
 794    if (h_recv-&gt;is_array_klass()
 795         ||
 796        InstanceKlass::cast(h_recv())-&gt;is_linked() &amp;&amp; !exact_receiver-&gt;is_interface()) {
 797      if (holder()-&gt;is_interface()) {
 798        m = LinkResolver::resolve_interface_call_or_null(h_recv, link_info);
 799      } else {
 800        m = LinkResolver::resolve_virtual_call_or_null(h_recv, link_info);
 801      }
 802    }
 803 
 804    if (m.is_null()) {
 805      // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 806      return NULL;
 807    }
 808 
 809    ciMethod* result = this;
 810    if (m() != get_Method()) {
 811      result = CURRENT_THREAD_ENV-&gt;get_method(m());
 812    }
 813 
 814    // Don't return abstract methods because they aren't
 815    // optimizable or interesting.
 816    if (result-&gt;is_abstract()) {
 817      return NULL;
 818    } else {
 819      return result;
 820    }
 821 }
 822 
 823 // ------------------------------------------------------------------
 824 // ciMethod::resolve_vtable_index
 825 //
 826 // Given a known receiver klass, find the vtable index for the call.
 827 // Return Method::invalid_vtable_index if the vtable_index is unknown.
 828 int ciMethod::resolve_vtable_index(ciKlass* caller, ciKlass* receiver) {
 829    check_is_loaded();
 830 
 831    int vtable_index = Method::invalid_vtable_index;
 832    // Only do lookup if receiver klass has been linked.  Otherwise,
 833    // the vtable has not been setup, and the LinkResolver will fail.
 834    if (!receiver-&gt;is_interface()
 835        &amp;&amp; (!receiver-&gt;is_instance_klass() ||
 836            receiver-&gt;as_instance_klass()-&gt;is_linked())) {
 837      VM_ENTRY_MARK;
 838 
 839      KlassHandle caller_klass (THREAD, caller-&gt;get_Klass());
 840      KlassHandle h_recv       (THREAD, receiver-&gt;get_Klass());
 841      Symbol* h_name = name()-&gt;get_symbol();
 842      Symbol* h_signature = signature()-&gt;get_symbol();
 843 
 844      LinkInfo link_info(h_recv, h_name, h_signature, caller_klass);
 845      vtable_index = LinkResolver::resolve_virtual_vtable_index(h_recv, link_info);
 846      if (vtable_index == Method::nonvirtual_vtable_index) {
 847        // A statically bound method.  Return "no such index".
 848        vtable_index = Method::invalid_vtable_index;
 849      }
 850    }
 851 
 852    return vtable_index;
 853 }
 854 
 855 // ------------------------------------------------------------------
 856 // ciMethod::interpreter_call_site_count
 857 int ciMethod::interpreter_call_site_count(int bci) {
 858   if (method_data() != NULL) {
 859     ResourceMark rm;
 860     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 861     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 862       return scale_count(data-&gt;as_CounterData()-&gt;count());
 863     }
 864   }
 865   return -1;  // unknown
 866 }
 867 
 868 // ------------------------------------------------------------------
 869 // ciMethod::get_field_at_bci
 870 ciField* ciMethod::get_field_at_bci(int bci, bool &amp;will_link) {
 871   ciBytecodeStream iter(this);
 872   iter.reset_to_bci(bci);
 873   iter.next();
 874   return iter.get_field(will_link);
 875 }
 876 
 877 // ------------------------------------------------------------------
 878 // ciMethod::get_method_at_bci
 879 ciMethod* ciMethod::get_method_at_bci(int bci, bool &amp;will_link, ciSignature* *declared_signature) {
 880   ciBytecodeStream iter(this);
 881   iter.reset_to_bci(bci);
 882   iter.next();
 883   return iter.get_method(will_link, declared_signature);
 884 }
 885 
 886 // ------------------------------------------------------------------
 887 // Adjust a CounterData count to be commensurate with
 888 // interpreter_invocation_count.  If the MDO exists for
 889 // only 25% of the time the method exists, then the
 890 // counts in the MDO should be scaled by 4X, so that
 891 // they can be usefully and stably compared against the
 892 // invocation counts in methods.
 893 int ciMethod::scale_count(int count, float prof_factor) {
 894   if (count &gt; 0 &amp;&amp; method_data() != NULL) {
 895     int counter_life;
 896     int method_life = interpreter_invocation_count();
 897     if (TieredCompilation) {
 898       // In tiered the MDO's life is measured directly, so just use the snapshotted counters
 899       counter_life = MAX2(method_data()-&gt;invocation_count(), method_data()-&gt;backedge_count());
 900     } else {
 901       int current_mileage = method_data()-&gt;current_mileage();
 902       int creation_mileage = method_data()-&gt;creation_mileage();
 903       counter_life = current_mileage - creation_mileage;
 904     }
 905 
 906     // counter_life due to backedge_counter could be &gt; method_life
 907     if (counter_life &gt; method_life)
 908       counter_life = method_life;
 909     if (0 &lt; counter_life &amp;&amp; counter_life &lt;= method_life) {
 910       count = (int)((double)count * prof_factor * method_life / counter_life + 0.5);
 911       count = (count &gt; 0) ? count : 1;
 912     }
 913   }
 914   return count;
 915 }
 916 
 917 
 918 // ------------------------------------------------------------------
 919 // ciMethod::is_special_get_caller_class_method
 920 //
 921 bool ciMethod::is_ignored_by_security_stack_walk() const {
 922   check_is_loaded();
 923   VM_ENTRY_MARK;
 924   return get_Method()-&gt;is_ignored_by_security_stack_walk();
 925 }
 926 
 927 
 928 // ------------------------------------------------------------------
 929 // invokedynamic support
 930 
 931 // ------------------------------------------------------------------
 932 // ciMethod::is_method_handle_intrinsic
 933 //
 934 // Return true if the method is an instance of the JVM-generated
 935 // signature-polymorphic MethodHandle methods, _invokeBasic, _linkToVirtual, etc.
 936 bool ciMethod::is_method_handle_intrinsic() const {
 937   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 938   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 939           MethodHandles::is_signature_polymorphic_intrinsic(iid));
 940 }
 941 
 942 // ------------------------------------------------------------------
 943 // ciMethod::is_compiled_lambda_form
 944 //
 945 // Return true if the method is a generated MethodHandle adapter.
 946 // These are built by Java code.
 947 bool ciMethod::is_compiled_lambda_form() const {
 948   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 949   return iid == vmIntrinsics::_compiledLambdaForm;
 950 }
 951 
 952 // ------------------------------------------------------------------
 953 // ciMethod::has_member_arg
 954 //
 955 // Return true if the method is a linker intrinsic like _linkToVirtual.
 956 // These are built by the JVM.
 957 bool ciMethod::has_member_arg() const {
 958   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 959   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 960           MethodHandles::has_member_arg(iid));
 961 }
 962 
 963 // ------------------------------------------------------------------
 964 // ciMethod::ensure_method_data
 965 //
 966 // Generate new MethodData* objects at compile time.
 967 // Return true if allocation was successful or no MDO is required.
 968 bool ciMethod::ensure_method_data(methodHandle h_m) {
 969   EXCEPTION_CONTEXT;
 970   if (is_native() || is_abstract() || h_m()-&gt;is_accessor()) {
 971     return true;
 972   }
 973   if (h_m()-&gt;method_data() == NULL) {
 974     Method::build_interpreter_method_data(h_m, THREAD);
 975     if (HAS_PENDING_EXCEPTION) {
 976       CLEAR_PENDING_EXCEPTION;
 977     }
 978   }
 979   if (h_m()-&gt;method_data() != NULL) {
 980     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
 981     _method_data-&gt;load_data();
 982     return true;
 983   } else {
 984     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
 985     return false;
 986   }
 987 }
 988 
 989 // public, retroactive version
 990 bool ciMethod::ensure_method_data() {
 991   bool result = true;
 992   if (_method_data == NULL || _method_data-&gt;is_empty()) {
 993     GUARDED_VM_ENTRY({
 994       result = ensure_method_data(get_Method());
 995     });
 996   }
 997   return result;
 998 }
 999 
1000 
1001 // ------------------------------------------------------------------
1002 // ciMethod::method_data
1003 //
1004 ciMethodData* ciMethod::method_data() {
1005   if (_method_data != NULL) {
1006     return _method_data;
1007   }
1008   VM_ENTRY_MARK;
1009   ciEnv* env = CURRENT_ENV;
1010   Thread* my_thread = JavaThread::current();
1011   methodHandle h_m(my_thread, get_Method());
1012 
1013   if (h_m()-&gt;method_data() != NULL) {
1014     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
1015     _method_data-&gt;load_data();
1016   } else {
1017     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
1018   }
1019   return _method_data;
1020 
1021 }
1022 
1023 // ------------------------------------------------------------------
1024 // ciMethod::method_data_or_null
1025 // Returns a pointer to ciMethodData if MDO exists on the VM side,
1026 // NULL otherwise.
1027 ciMethodData* ciMethod::method_data_or_null() {
1028   ciMethodData *md = method_data();
1029   if (md-&gt;is_empty()) {
1030     return NULL;
1031   }
1032   return md;
1033 }
1034 
1035 // ------------------------------------------------------------------
1036 // ciMethod::ensure_method_counters
1037 //
1038 MethodCounters* ciMethod::ensure_method_counters() {
1039   check_is_loaded();
1040   VM_ENTRY_MARK;
1041   methodHandle mh(THREAD, get_Method());
1042   MethodCounters* method_counters = mh-&gt;get_method_counters(CHECK_NULL);
1043   return method_counters;
1044 }
1045 
1046 // ------------------------------------------------------------------
1047 // ciMethod::has_option
1048 //
1049 bool ciMethod::has_option(const char* option) {
1050   check_is_loaded();
1051   VM_ENTRY_MARK;
1052   methodHandle mh(THREAD, get_Method());
1053   return CompilerOracle::has_option_string(mh, option);
1054 }
1055 
1056 // ------------------------------------------------------------------
1057 // ciMethod::has_option_value
1058 //
1059 bool ciMethod::has_option_value(const char* option, double&amp; value) {
1060   check_is_loaded();
1061   VM_ENTRY_MARK;
1062   methodHandle mh(THREAD, get_Method());
1063   return CompilerOracle::has_option_value(mh, option, value);
1064 }
1065 // ------------------------------------------------------------------
1066 // ciMethod::can_be_compiled
1067 //
1068 // Have previous compilations of this method succeeded?
1069 bool ciMethod::can_be_compiled() {
1070   check_is_loaded();
1071   ciEnv* env = CURRENT_ENV;
1072   if (is_c1_compile(env-&gt;comp_level())) {
1073     return _is_c1_compilable;
1074   }
1075   return _is_c2_compilable;
1076 }
1077 
1078 // ------------------------------------------------------------------
1079 // ciMethod::set_not_compilable
1080 //
1081 // Tell the VM that this method cannot be compiled at all.
1082 void ciMethod::set_not_compilable(const char* reason) {
1083   check_is_loaded();
1084   VM_ENTRY_MARK;
1085   ciEnv* env = CURRENT_ENV;
1086   if (is_c1_compile(env-&gt;comp_level())) {
1087     _is_c1_compilable = false;
1088   } else {
1089     _is_c2_compilable = false;
1090   }
1091   get_Method()-&gt;set_not_compilable(env-&gt;comp_level(), true, reason);
1092 }
1093 
1094 // ------------------------------------------------------------------
1095 // ciMethod::can_be_osr_compiled
1096 //
1097 // Have previous compilations of this method succeeded?
1098 //
1099 // Implementation note: the VM does not currently keep track
1100 // of failed OSR compilations per bci.  The entry_bci parameter
1101 // is currently unused.
1102 bool ciMethod::can_be_osr_compiled(int entry_bci) {
1103   check_is_loaded();
1104   VM_ENTRY_MARK;
1105   ciEnv* env = CURRENT_ENV;
1106   return !get_Method()-&gt;is_not_osr_compilable(env-&gt;comp_level());
1107 }
1108 
1109 // ------------------------------------------------------------------
1110 // ciMethod::has_compiled_code
1111 bool ciMethod::has_compiled_code() {
1112   return instructions_size() &gt; 0;
1113 }
1114 
1115 int ciMethod::comp_level() {
1116   check_is_loaded();
1117   VM_ENTRY_MARK;
1118   nmethod* nm = get_Method()-&gt;code();
1119   if (nm != NULL) return nm-&gt;comp_level();
1120   return 0;
1121 }
1122 
1123 int ciMethod::highest_osr_comp_level() {
1124   check_is_loaded();
1125   VM_ENTRY_MARK;
1126   return get_Method()-&gt;highest_osr_comp_level();
1127 }
1128 
1129 // ------------------------------------------------------------------
1130 // ciMethod::code_size_for_inlining
1131 //
1132 // Code size for inlining decisions.  This method returns a code
1133 // size of 1 for methods which has the ForceInline annotation.
1134 int ciMethod::code_size_for_inlining() {
1135   check_is_loaded();
1136   if (get_Method()-&gt;force_inline()) {
1137     return 1;
1138   }
1139   return code_size();
1140 }
1141 
1142 // ------------------------------------------------------------------
1143 // ciMethod::instructions_size
1144 //
1145 // This is a rough metric for "fat" methods, compared before inlining
1146 // with InlineSmallCode.  The CodeBlob::code_size accessor includes
1147 // junk like exception handler, stubs, and constant table, which are
1148 // not highly relevant to an inlined method.  So we use the more
1149 // specific accessor nmethod::insts_size.
1150 int ciMethod::instructions_size() {
1151   if (_instructions_size == -1) {
1152     GUARDED_VM_ENTRY(
1153                      nmethod* code = get_Method()-&gt;code();
1154                      if (code != NULL &amp;&amp; (code-&gt;comp_level() == CompLevel_full_optimization)) {
1155                        _instructions_size = code-&gt;insts_end() - code-&gt;verified_entry_point();
1156                      } else {
1157                        _instructions_size = 0;
1158                      }
1159                      );
1160   }
1161   return _instructions_size;
1162 }
1163 
1164 // ------------------------------------------------------------------
1165 // ciMethod::log_nmethod_identity
1166 void ciMethod::log_nmethod_identity(xmlStream* log) {
1167   GUARDED_VM_ENTRY(
1168     nmethod* code = get_Method()-&gt;code();
1169     if (code != NULL) {
1170       code-&gt;log_identity(log);
1171     }
1172   )
1173 }
1174 
1175 // ------------------------------------------------------------------
1176 // ciMethod::is_not_reached
1177 bool ciMethod::is_not_reached(int bci) {
1178   check_is_loaded();
1179   VM_ENTRY_MARK;
1180   return Interpreter::is_not_reached(
1181                methodHandle(THREAD, get_Method()), bci);
1182 }
1183 
1184 // ------------------------------------------------------------------
1185 // ciMethod::was_never_executed
1186 bool ciMethod::was_executed_more_than(int times) {
1187   VM_ENTRY_MARK;
1188   return get_Method()-&gt;was_executed_more_than(times);
1189 }
1190 
1191 // ------------------------------------------------------------------
1192 // ciMethod::has_unloaded_classes_in_signature
1193 bool ciMethod::has_unloaded_classes_in_signature() {
1194   VM_ENTRY_MARK;
1195   {
1196     EXCEPTION_MARK;
1197     methodHandle m(THREAD, get_Method());
1198     bool has_unloaded = Method::has_unloaded_classes_in_signature(m, (JavaThread *)THREAD);
1199     if( HAS_PENDING_EXCEPTION ) {
1200       CLEAR_PENDING_EXCEPTION;
1201       return true;     // Declare that we may have unloaded classes
1202     }
1203     return has_unloaded;
1204   }
1205 }
1206 
1207 // ------------------------------------------------------------------
1208 // ciMethod::is_klass_loaded
1209 bool ciMethod::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
1210   VM_ENTRY_MARK;
1211   return get_Method()-&gt;is_klass_loaded(refinfo_index, must_be_resolved);
1212 }
1213 
1214 // ------------------------------------------------------------------
1215 // ciMethod::check_call
1216 bool ciMethod::check_call(int refinfo_index, bool is_static) const {
1217   // This method is used only in C2 from InlineTree::ok_to_inline,
1218   // and is only used under -Xcomp or -XX:CompileTheWorld.
1219   // It appears to fail when applied to an invokeinterface call site.
1220   // FIXME: Remove this method and resolve_method_statically; refactor to use the other LinkResolver entry points.
1221   VM_ENTRY_MARK;
1222   {
1223     EXCEPTION_MARK;
1224     HandleMark hm(THREAD);
1225     constantPoolHandle pool (THREAD, get_Method()-&gt;constants());
1226     Bytecodes::Code code = (is_static ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual);
1227     methodHandle spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);
1228     if (HAS_PENDING_EXCEPTION) {
1229       CLEAR_PENDING_EXCEPTION;
1230       return false;
1231     } else {
1232       return (spec_method-&gt;is_static() == is_static);
1233     }
1234   }
1235   return false;
1236 }
1237 
1238 // ------------------------------------------------------------------
1239 // ciMethod::profile_aging
1240 //
1241 // Should the method be compiled with an age counter?
1242 bool ciMethod::profile_aging() const {
1243   return UseCodeAging &amp;&amp; (!MethodCounters::is_nmethod_hot(nmethod_age()) &amp;&amp;
1244                           !MethodCounters::is_nmethod_age_unset(nmethod_age()));
1245 }
1246 // ------------------------------------------------------------------
1247 // ciMethod::print_codes
1248 //
1249 // Print the bytecodes for this method.
1250 void ciMethod::print_codes_on(outputStream* st) {
1251   check_is_loaded();
1252   GUARDED_VM_ENTRY(get_Method()-&gt;print_codes_on(st);)
1253 }
1254 
1255 
1256 #define FETCH_FLAG_FROM_VM(flag_accessor) { \
1257   check_is_loaded(); \
1258   VM_ENTRY_MARK; \
1259   return get_Method()-&gt;flag_accessor(); \
1260 }
1261 
1262 bool ciMethod::is_empty_method() const {         FETCH_FLAG_FROM_VM(is_empty_method); }
1263 bool ciMethod::is_vanilla_constructor() const {  FETCH_FLAG_FROM_VM(is_vanilla_constructor); }
1264 bool ciMethod::has_loops      () const {         FETCH_FLAG_FROM_VM(has_loops); }
1265 bool ciMethod::has_jsrs       () const {         FETCH_FLAG_FROM_VM(has_jsrs);  }
1266 bool ciMethod::is_getter      () const {         FETCH_FLAG_FROM_VM(is_getter); }
1267 bool ciMethod::is_setter      () const {         FETCH_FLAG_FROM_VM(is_setter); }
1268 bool ciMethod::is_accessor    () const {         FETCH_FLAG_FROM_VM(is_accessor); }
1269 bool ciMethod::is_initializer () const {         FETCH_FLAG_FROM_VM(is_initializer); }
1270 
1271 bool ciMethod::is_boxing_method() const {
1272   if (holder()-&gt;is_box_klass()) {
1273     switch (intrinsic_id()) {
1274       case vmIntrinsics::_Boolean_valueOf:
1275       case vmIntrinsics::_Byte_valueOf:
1276       case vmIntrinsics::_Character_valueOf:
1277       case vmIntrinsics::_Short_valueOf:
1278       case vmIntrinsics::_Integer_valueOf:
1279       case vmIntrinsics::_Long_valueOf:
1280       case vmIntrinsics::_Float_valueOf:
1281       case vmIntrinsics::_Double_valueOf:
1282         return true;
1283       default:
1284         return false;
1285     }
1286   }
1287   return false;
1288 }
1289 
1290 bool ciMethod::is_unboxing_method() const {
1291   if (holder()-&gt;is_box_klass()) {
1292     switch (intrinsic_id()) {
1293       case vmIntrinsics::_booleanValue:
1294       case vmIntrinsics::_byteValue:
1295       case vmIntrinsics::_charValue:
1296       case vmIntrinsics::_shortValue:
1297       case vmIntrinsics::_intValue:
1298       case vmIntrinsics::_longValue:
1299       case vmIntrinsics::_floatValue:
1300       case vmIntrinsics::_doubleValue:
1301         return true;
1302       default:
1303         return false;
1304     }
1305   }
1306   return false;
1307 }
1308 
1309 BCEscapeAnalyzer  *ciMethod::get_bcea() {
1310 #ifdef COMPILER2
1311   if (_bcea == NULL) {
1312     _bcea = new (CURRENT_ENV-&gt;arena()) BCEscapeAnalyzer(this, NULL);
1313   }
1314   return _bcea;
1315 #else // COMPILER2
1316   ShouldNotReachHere();
1317   return NULL;
1318 #endif // COMPILER2
1319 }
1320 
1321 ciMethodBlocks  *ciMethod::get_method_blocks() {
1322   Arena *arena = CURRENT_ENV-&gt;arena();
1323   if (_method_blocks == NULL) {
1324     _method_blocks = new (arena) ciMethodBlocks(arena, this);
1325   }
1326   return _method_blocks;
1327 }
1328 
1329 #undef FETCH_FLAG_FROM_VM
1330 
1331 void ciMethod::dump_name_as_ascii(outputStream* st) {
1332   Method* method = get_Method();
1333   st-&gt;print("%s %s %s",
1334             method-&gt;klass_name()-&gt;as_quoted_ascii(),
1335             method-&gt;name()-&gt;as_quoted_ascii(),
1336             method-&gt;signature()-&gt;as_quoted_ascii());
1337 }
1338 
1339 void ciMethod::dump_replay_data(outputStream* st) {
1340   ResourceMark rm;
1341   Method* method = get_Method();
1342   MethodCounters* mcs = method-&gt;method_counters();
1343   st-&gt;print("ciMethod ");
1344   dump_name_as_ascii(st);
1345   st-&gt;print_cr(" %d %d %d %d %d",
1346                mcs == NULL ? 0 : mcs-&gt;invocation_counter()-&gt;raw_counter(),
1347                mcs == NULL ? 0 : mcs-&gt;backedge_counter()-&gt;raw_counter(),
1348                interpreter_invocation_count(),
1349                interpreter_throwout_count(),
1350                _instructions_size);
1351 }
1352 
1353 // ------------------------------------------------------------------
1354 // ciMethod::print_codes
1355 //
1356 // Print a range of the bytecodes for this method.
1357 void ciMethod::print_codes_on(int from, int to, outputStream* st) {
1358   check_is_loaded();
1359   GUARDED_VM_ENTRY(get_Method()-&gt;print_codes_on(from, to, st);)
1360 }
1361 
1362 // ------------------------------------------------------------------
1363 // ciMethod::print_name
1364 //
1365 // Print the name of this method, including signature and some flags.
1366 void ciMethod::print_name(outputStream* st) {
1367   check_is_loaded();
1368   GUARDED_VM_ENTRY(get_Method()-&gt;print_name(st);)
1369 }
1370 
1371 // ------------------------------------------------------------------
1372 // ciMethod::print_short_name
1373 //
1374 // Print the name of this method, without signature.
1375 void ciMethod::print_short_name(outputStream* st) {
1376   if (is_loaded()) {
1377     GUARDED_VM_ENTRY(get_Method()-&gt;print_short_name(st););
1378   } else {
1379     // Fall back if method is not loaded.
1380     holder()-&gt;print_name_on(st);
1381     st-&gt;print("::");
1382     name()-&gt;print_symbol_on(st);
1383     if (WizardMode)
1384       signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1385   }
1386 }
1387 
1388 // ------------------------------------------------------------------
1389 // ciMethod::print_impl
1390 //
1391 // Implementation of the print method.
1392 void ciMethod::print_impl(outputStream* st) {
1393   ciMetadata::print_impl(st);
1394   st-&gt;print(" name=");
1395   name()-&gt;print_symbol_on(st);
1396   st-&gt;print(" holder=");
1397   holder()-&gt;print_name_on(st);
1398   st-&gt;print(" signature=");
1399   signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1400   if (is_loaded()) {
1401     st-&gt;print(" loaded=true");
1402     st-&gt;print(" arg_size=%d", arg_size());
1403     st-&gt;print(" flags=");
1404     flags().print_member_flags(st);
1405   } else {
1406     st-&gt;print(" loaded=false");
1407   }
1408 }
1409 
1410 #if INCLUDE_TRACE
1411 TraceStructCiMethod ciMethod::to_trace_struct() const {
1412   TraceStructCiMethod result;
1413   result.set_class(holder()-&gt;name()-&gt;as_utf8());
1414   result.set_name(name()-&gt;as_utf8());
1415   result.set_signature(signature()-&gt;as_symbol()-&gt;as_utf8());
1416   return result;
1417 }
1418 #endif
</pre></body></html>
