<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_VM_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include "classfile/classLoaderData.hpp"
  29 #include "gc/shared/specialized_oop_closures.hpp"
  30 #include "logging/logLevel.hpp"
  31 #include "memory/referenceType.hpp"
  32 #include "oops/annotations.hpp"
  33 #include "oops/constMethod.hpp"
  34 #include "oops/fieldInfo.hpp"
  35 #include "oops/instanceOop.hpp"
  36 #include "oops/klassVtable.hpp"
  37 #include "runtime/handles.hpp"
  38 #include "runtime/os.hpp"
  39 #include "trace/traceMacros.hpp"
  40 #include "utilities/accessFlags.hpp"
  41 #include "utilities/bitMap.inline.hpp"
  42 #include "utilities/macros.hpp"
  43 
  44 // An InstanceKlass is the VM level representation of a Java class.
  45 // It contains all information needed for at class at execution runtime.
  46 
  47 //  InstanceKlass embedded field layout (after declared fields):
  48 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  49 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  50 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  51 //      indicating where oops are located in instances of this klass.
  52 //    [EMBEDDED implementor of the interface] only exist for interface
  53 //    [EMBEDDED host klass        ] only exist for an anonymous class (JSR 292 enabled)
  54 
  55 
  56 // forward declaration for class -- see below for definition
  57 class BreakpointInfo;
  58 class ClassFileParser;
  59 class KlassDepChange;
  60 class DependencyContext;
  61 class fieldDescriptor;
  62 class jniIdMapBase;
  63 class JNIid;
  64 class JvmtiCachedClassFieldMap;
  65 class MemberNameTable;
  66 class SuperTypeClosure;
  67 
  68 // This is used in iterators below.
  69 class FieldClosure: public StackObj {
  70 public:
  71   virtual void do_field(fieldDescriptor* fd) = 0;
  72 };
  73 
  74 #ifndef PRODUCT
  75 // Print fields.
  76 // If "obj" argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  77 class FieldPrinter: public FieldClosure {
  78    oop _obj;
  79    outputStream* _st;
  80  public:
  81    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  82    void do_field(fieldDescriptor* fd);
  83 };
  84 #endif  // !PRODUCT
  85 
  86 // ValueObjs embedded in klass. Describes where oops are located in instances of
  87 // this klass.
  88 class OopMapBlock VALUE_OBJ_CLASS_SPEC {
  89  public:
  90   // Byte offset of the first oop mapped by this block.
  91   int offset() const          { return _offset; }
  92   void set_offset(int offset) { _offset = offset; }
  93 
  94   // Number of oops in this block.
  95   uint count() const         { return _count; }
  96   void set_count(uint count) { _count = count; }
  97 
  98   // sizeof(OopMapBlock) in words.
  99   static const int size_in_words() {
 100     return align_size_up(int(sizeof(OopMapBlock)), wordSize) &gt;&gt;
 101       LogBytesPerWord;
 102   }
 103 
 104  private:
 105   int  _offset;
 106   uint _count;
 107 };
 108 
 109 struct JvmtiCachedClassFileData;
 110 
 111 class InstanceKlass: public Klass {
 112   friend class VMStructs;
 113   friend class JVMCIVMStructs;
 114   friend class ClassFileParser;
 115   friend class CompileReplay;
<a name="1" id="anc1"></a>
 116 
 117  protected:
 118   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind);
 119 
 120  public:
 121   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
 122 
 123   // See "The Java Virtual Machine Specification" section 2.16.2-5 for a detailed description
 124   // of the class loading &amp; initialization procedure, and the use of the states.
 125   enum ClassState {
 126     allocated,                          // allocated (but not yet linked)
 127     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 128     linked,                             // successfully linked/verified (but not initialized yet)
 129     being_initialized,                  // currently running class initializer
 130     fully_initialized,                  // initialized (successfull final state)
 131     initialization_error                // error happened during initialization
 132   };
 133 
 134   static int number_of_instance_classes() { return _total_instanceKlass_count; }
 135 
 136  private:
 137   static volatile int _total_instanceKlass_count;
 138   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 139 
 140  protected:
 141   // Annotations for this class
 142   Annotations*    _annotations;
 143   // Array classes holding elements of this class.
 144   Klass*          _array_klasses;
 145   // Constant pool for this class.
 146   ConstantPool* _constants;
 147   // The InnerClasses attribute and EnclosingMethod attribute. The
 148   // _inner_classes is an array of shorts. If the class has InnerClasses
 149   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 150   // [inner_class_info_index, outer_class_info_index,
 151   // inner_name_index, inner_class_access_flags] for the InnerClasses
 152   // attribute. If the EnclosingMethod attribute exists, it occupies the
 153   // last two shorts [class_index, method_index] of the array. If only
 154   // the InnerClasses attribute exists, the _inner_classes array length is
 155   // number_of_inner_classes * 4. If the class has both InnerClasses
 156   // and EnclosingMethod attributes the _inner_classes array length is
 157   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 158   Array&lt;jushort&gt;* _inner_classes;
 159 
 160   // the source debug extension for this klass, NULL if not specified.
 161   // Specified as UTF-8 string without terminating zero byte in the classfile,
 162   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 163   const char*     _source_debug_extension;
 164   // Array name derived from this class which needs unreferencing
 165   // if this class is unloaded.
 166   Symbol*         _array_name;
 167 
 168   // Number of heapOopSize words used by non-static fields in this klass
 169   // (including inherited fields but after header_size()).
 170   int             _nonstatic_field_size;
 171   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 172   // Constant pool index to the utf8 entry of the Generic signature,
 173   // or 0 if none.
 174   u2              _generic_signature_index;
 175   // Constant pool index to the utf8 entry for the name of source file
 176   // containing this klass, 0 if not specified.
 177   u2              _source_file_name_index;
 178   u2              _static_oop_field_count;// number of static oop fields in this klass
 179   u2              _java_fields_count;    // The number of declared Java fields
 180   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 181 
 182   int             _itable_len;           // length of Java itable (in words)
 183   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 184   // _misc_flags.
 185   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 186 
 187   // The low two bits of _misc_flags contains the kind field.
 188   // This can be used to quickly discriminate among the four kinds of
 189   // InstanceKlass.
 190 
 191   static const unsigned _misc_kind_field_size = 2;
 192   static const unsigned _misc_kind_field_pos  = 0;
 193   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 194 
 195   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 196   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 197   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 198   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 199 
 200   // Start after _misc_kind field.
 201   enum {
 202     _misc_rewritten                = 1 &lt;&lt; 2, // methods rewritten.
 203     _misc_has_nonstatic_fields     = 1 &lt;&lt; 3, // for sizing with UseCompressedOops
 204     _misc_should_verify_class      = 1 &lt;&lt; 4, // allow caching of preverification
 205     _misc_is_anonymous             = 1 &lt;&lt; 5, // has embedded _host_klass field
 206     _misc_is_contended             = 1 &lt;&lt; 6, // marked with contended annotation
 207     _misc_has_default_methods      = 1 &lt;&lt; 7, // class/superclass/implemented interfaces has default methods
 208     _misc_declares_default_methods = 1 &lt;&lt; 8, // directly declares default methods (any access)
 209     _misc_has_been_redefined       = 1 &lt;&lt; 9, // class has been redefined
 210     _misc_is_scratch_class         = 1 &lt;&lt; 10 // class is the redefined scratch class
 211   };
 212   u2              _misc_flags;
 213   u2              _minor_version;        // minor version number of class file
 214   u2              _major_version;        // major version number of class file
 215   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)
 216   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 217   MemberNameTable* _member_names;        // Member names
 218   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 219   jmethodID*      _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 220   intptr_t        _dep_context;          // packed DependencyContext structure
 221   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 222   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 223   // Linked instanceKlasses of previous versions
 224   InstanceKlass* _previous_versions;
 225   // JVMTI fields can be moved to their own structure - see 6315920
 226   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 227   JvmtiCachedClassFileData* _cached_class_file;
 228 
 229   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don't change
 230 
 231   // Class states are defined as ClassState (see above).
 232   // Place the _init_state here to utilize the unused 2-byte after
 233   // _idnum_allocated_count.
 234   u1              _init_state;                    // state of class
 235   u1              _reference_type;                // reference type
 236 
 237   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 238 
 239   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 240 
 241   // Method array.
 242   Array&lt;Method*&gt;* _methods;
 243   // Default Method Array, concrete methods inherited from interfaces
 244   Array&lt;Method*&gt;* _default_methods;
 245   // Interface (Klass*s) this class declares locally to implement.
 246   Array&lt;Klass*&gt;* _local_interfaces;
 247   // Interface (Klass*s) this class implements transitively.
 248   Array&lt;Klass*&gt;* _transitive_interfaces;
 249   // Int array containing the original order of method in the class file (for JVMTI).
 250   Array&lt;int&gt;*     _method_ordering;
 251   // Int array containing the vtable_indices for default_methods
 252   // offset matches _default_methods offset
 253   Array&lt;int&gt;*     _default_vtable_indices;
 254 
 255   // Instance and static variable information, starts with 6-tuples of shorts
 256   // [access, name index, sig index, initval index, low_offset, high_offset]
 257   // for all fields, followed by the generic signature data at the end of
 258   // the array. Only fields with generic signature attributes have the generic
 259   // signature data set in the array. The fields array looks like following:
 260   //
 261   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 262   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 263   //      ...
 264   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 265   //     [generic signature index]
 266   //     [generic signature index]
 267   //     ...
 268   Array&lt;u2&gt;*      _fields;
 269 
 270   // embedded Java vtable follows here
 271   // embedded Java itables follows here
 272   // embedded static fields follows here
 273   // embedded nonstatic oop-map blocks follows here
 274   // embedded implementor of this interface follows here
 275   //   The embedded implementor only exists if the current klass is an
 276   //   iterface. The possible values of the implementor fall into following
 277   //   three cases:
 278   //     NULL: no implementor.
 279   //     A Klass* that's not itself: one implementor.
 280   //     Itself: more than one implementors.
 281   // embedded host klass follows here
 282   //   The embedded host klass only exists in an anonymous class for
 283   //   dynamic language support (JSR 292 enabled). The host class grants
 284   //   its access privileges to this class also. The host class is either
 285   //   named, or a previously loaded anonymous class. A non-anonymous class
 286   //   or an anonymous class loaded through normal classloading does not
 287   //   have this embedded field.
 288   //
 289 
 290   friend class SystemDictionary;
 291 
 292  public:
 293   bool has_nonstatic_fields() const        {
 294     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 295   }
 296   void set_has_nonstatic_fields(bool b)    {
 297     if (b) {
 298       _misc_flags |= _misc_has_nonstatic_fields;
 299     } else {
 300       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 301     }
 302   }
 303 
 304   // field sizes
 305   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 306   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 307 
 308   int static_field_size() const            { return _static_field_size; }
 309   void set_static_field_size(int size)     { _static_field_size = size; }
 310 
 311   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 312   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 313 
 314   // Java itable
 315   int  itable_length() const               { return _itable_len; }
 316   void set_itable_length(int len)          { _itable_len = len; }
 317 
 318   // array klasses
 319   Klass* array_klasses() const             { return _array_klasses; }
 320   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 321 
 322   // methods
 323   Array&lt;Method*&gt;* methods() const          { return _methods; }
 324   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 325   Method* method_with_idnum(int idnum);
 326   Method* method_with_orig_idnum(int idnum);
 327   Method* method_with_orig_idnum(int idnum, int version);
 328 
 329   // method ordering
 330   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 331   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 332   void copy_method_ordering(const intArray* m, TRAPS);
 333 
 334   // default_methods
 335   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 336   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 337 
 338   // default method vtable_indices
 339   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 340   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 341   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 342 
 343   // interfaces
 344   Array&lt;Klass*&gt;* local_interfaces() const          { return _local_interfaces; }
 345   void set_local_interfaces(Array&lt;Klass*&gt;* a)      {
 346     guarantee(_local_interfaces == NULL || a == NULL, "Just checking");
 347     _local_interfaces = a; }
 348 
 349   Array&lt;Klass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 350   void set_transitive_interfaces(Array&lt;Klass*&gt;* a) {
 351     guarantee(_transitive_interfaces == NULL || a == NULL, "Just checking");
 352     _transitive_interfaces = a;
 353   }
 354 
 355  private:
 356   friend class fieldDescriptor;
 357   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 358 
 359  public:
 360   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 361   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 362   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 363   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 364 
 365   // Number of Java declared fields
 366   int java_fields_count() const           { return (int)_java_fields_count; }
 367 
 368   Array&lt;u2&gt;* fields() const            { return _fields; }
 369   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 370     guarantee(_fields == NULL || f == NULL, "Just checking");
 371     _fields = f;
 372     _java_fields_count = java_fields_count;
 373   }
 374 
 375   // inner classes
 376   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 377   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 378 
 379   enum InnerClassAttributeOffset {
 380     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 381     inner_class_inner_class_info_offset = 0,
 382     inner_class_outer_class_info_offset = 1,
 383     inner_class_inner_name_offset = 2,
 384     inner_class_access_flags_offset = 3,
 385     inner_class_next_offset = 4
 386   };
 387 
 388   enum EnclosingMethodAttributeOffset {
 389     enclosing_method_class_index_offset = 0,
 390     enclosing_method_method_index_offset = 1,
 391     enclosing_method_attribute_size = 2
 392   };
 393 
 394   // method override check
 395   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 396 
 397   // package
 398   bool is_same_class_package(const Klass* class2) const;
 399   bool is_same_class_package(oop classloader2, const Symbol* classname2) const;
 400   static bool is_same_class_package(oop class_loader1,
 401                                     const Symbol* class_name1,
 402                                     oop class_loader2,
 403                                     const Symbol* class_name2);
 404 
 405   // find an enclosing class
 406   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const {
 407     return compute_enclosing_class_impl(this, inner_is_member, THREAD);
 408   }
 409   static InstanceKlass* compute_enclosing_class_impl(const InstanceKlass* self,
 410                                                      bool* inner_is_member,
 411                                                      TRAPS);
 412 
 413   // Find InnerClasses attribute for k and return outer_class_info_index &amp; inner_name_index.
 414   static bool find_inner_classes_attr(instanceKlassHandle k,
 415                                       int* ooff, int* noff, TRAPS);
 416 
 417   // tell if two classes have the same enclosing class (at package level)
 418   bool is_same_package_member(const Klass* class2, TRAPS) const {
 419     return is_same_package_member_impl(this, class2, THREAD);
 420   }
 421   static bool is_same_package_member_impl(const InstanceKlass* self,
 422                                           const Klass* class2,
 423                                           TRAPS);
 424 
 425   // initialization state
 426   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 427   bool is_linked() const                   { return _init_state &gt;= linked; }
 428   bool is_initialized() const              { return _init_state == fully_initialized; }
 429   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 430   bool is_being_initialized() const        { return _init_state == being_initialized; }
 431   bool is_in_error_state() const           { return _init_state == initialization_error; }
 432   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 433   ClassState  init_state()                 { return (ClassState)_init_state; }
 434   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 435 
 436   // defineClass specified verification
 437   bool should_verify_class() const         {
 438     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 439   }
 440   void set_should_verify_class(bool value) {
 441     if (value) {
 442       _misc_flags |= _misc_should_verify_class;
 443     } else {
 444       _misc_flags &amp;= ~_misc_should_verify_class;
 445     }
 446   }
 447 
 448   // marking
 449   bool is_marked_dependent() const         { return _is_marked_dependent; }
 450   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 451 
 452   // initialization (virtuals from Klass)
 453   bool should_be_initialized() const;  // means that initialize should be called
 454   void initialize(TRAPS);
 455   void link_class(TRAPS);
 456   bool link_class_or_fail(TRAPS); // returns false on failure
 457   void unlink_class();
 458   void rewrite_class(TRAPS);
 459   void link_methods(TRAPS);
 460   Method* class_initializer();
 461 
 462   // set the class to initialized if no static initializer is present
 463   void eager_initialize(Thread *thread);
 464 
 465   // reference type
 466   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 467   void set_reference_type(ReferenceType t) {
 468     assert(t == (u1)t, "overflow");
 469     _reference_type = (u1)t;
 470   }
 471 
 472   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 473 
 474   // find local field, returns true if found
 475   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 476   // find field in direct superinterfaces, returns the interface in which the field is defined
 477   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 478   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 479   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 480   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 481   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 482 
 483   // find a non-static or static field given its offset within the class.
 484   bool contains_field_offset(int offset) {
 485     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());
 486   }
 487 
 488   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 489   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 490 
 491   // find a local method (returns NULL if not found)
 492   Method* find_method(const Symbol* name, const Symbol* signature) const;
 493   static Method* find_method(const Array&lt;Method*&gt;* methods,
 494                              const Symbol* name,
 495                              const Symbol* signature);
 496 
 497   // find a local method, but skip static methods
 498   Method* find_instance_method(const Symbol* name, const Symbol* signature) const;
 499   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 500                                       const Symbol* name,
 501                                       const Symbol* signature);
 502 
 503   // find a local method (returns NULL if not found)
 504   Method* find_local_method(const Symbol* name,
 505                             const Symbol* signature,
 506                             OverpassLookupMode overpass_mode,
 507                             StaticLookupMode static_mode,
 508                             PrivateLookupMode private_mode) const;
 509 
 510   // find a local method from given methods array (returns NULL if not found)
 511   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 512                                    const Symbol* name,
 513                                    const Symbol* signature,
 514                                    OverpassLookupMode overpass_mode,
 515                                    StaticLookupMode static_mode,
 516                                    PrivateLookupMode private_mode);
 517 
 518   // find a local method index in methods or default_methods (returns -1 if not found)
 519   static int find_method_index(const Array&lt;Method*&gt;* methods,
 520                                const Symbol* name,
 521                                const Symbol* signature,
 522                                OverpassLookupMode overpass_mode,
 523                                StaticLookupMode static_mode,
 524                                PrivateLookupMode private_mode);
 525 
 526   // lookup operation (returns NULL if not found)
 527   Method* uncached_lookup_method(const Symbol* name,
 528                                  const Symbol* signature,
 529                                  OverpassLookupMode overpass_mode) const;
 530 
 531   // lookup a method in all the interfaces that this class implements
 532   // (returns NULL if not found)
 533   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 534 
 535   // lookup a method in local defaults then in all interfaces
 536   // (returns NULL if not found)
 537   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 538 
 539   // Find method indices by name.  If a method with the specified name is
 540   // found the index to the first method is returned, and 'end' is filled in
 541   // with the index of first non-name-matching method.  If no method is found
 542   // -1 is returned.
 543   int find_method_by_name(const Symbol* name, int* end) const;
 544   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 545                                  const Symbol* name, int* end);
 546 
 547   // constant pool
 548   ConstantPool* constants() const        { return _constants; }
 549   void set_constants(ConstantPool* c)    { _constants = c; }
 550 
 551   // protection domain
 552   oop protection_domain() const;
 553 
 554   // signers
 555   objArrayOop signers() const;
 556 
 557   // host class
 558   Klass* host_klass() const              {
 559     Klass** hk = (Klass**)adr_host_klass();
 560     if (hk == NULL) {
 561       return NULL;
 562     } else {
 563       assert(*hk != NULL, "host klass should always be set if the address is not null");
 564       return *hk;
 565     }
 566   }
 567   void set_host_klass(const Klass* host) {
 568     assert(is_anonymous(), "not anonymous");
 569     const Klass** addr = (const Klass**)adr_host_klass();
 570     assert(addr != NULL, "no reversed space");
 571     if (addr != NULL) {
 572       *addr = host;
 573     }
 574   }
 575   bool is_anonymous() const                {
 576     return (_misc_flags &amp; _misc_is_anonymous) != 0;
 577   }
 578   void set_is_anonymous(bool value)        {
 579     if (value) {
 580       _misc_flags |= _misc_is_anonymous;
 581     } else {
 582       _misc_flags &amp;= ~_misc_is_anonymous;
 583     }
 584   }
 585 
 586   // Oop that keeps the metadata for this class from being unloaded
 587   // in places where the metadata is stored in other places, like nmethods
 588   oop klass_holder() const {
 589     return is_anonymous() ? java_mirror() : class_loader();
 590   }
 591 
 592   bool is_contended() const                {
 593     return (_misc_flags &amp; _misc_is_contended) != 0;
 594   }
 595   void set_is_contended(bool value)        {
 596     if (value) {
 597       _misc_flags |= _misc_is_contended;
 598     } else {
 599       _misc_flags &amp;= ~_misc_is_contended;
 600     }
 601   }
 602 
 603   // source file name
 604   Symbol* source_file_name() const               {
 605     return (_source_file_name_index == 0) ?
 606       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 607   }
 608   u2 source_file_name_index() const              {
 609     return _source_file_name_index;
 610   }
 611   void set_source_file_name_index(u2 sourcefile_index) {
 612     _source_file_name_index = sourcefile_index;
 613   }
 614 
 615   // minor and major version numbers of class file
 616   u2 minor_version() const                 { return _minor_version; }
 617   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 618   u2 major_version() const                 { return _major_version; }
 619   void set_major_version(u2 major_version) { _major_version = major_version; }
 620 
 621   // source debug extension
 622   const char* source_debug_extension() const { return _source_debug_extension; }
 623   void set_source_debug_extension(const char* array, int length);
 624 
 625   // symbol unloading support (refcount already added)
 626   Symbol* array_name()                     { return _array_name; }
 627   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, "name already created"); _array_name = name; }
 628 
 629   // nonstatic oop-map blocks
 630   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 631     return oop_map_count * OopMapBlock::size_in_words();
 632   }
 633   unsigned int nonstatic_oop_map_count() const {
 634     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 635   }
 636   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 637   void set_nonstatic_oop_map_size(int words) {
 638     _nonstatic_oop_map_size = words;
 639   }
 640 
 641   // RedefineClasses() support for previous versions:
 642   void add_previous_version(instanceKlassHandle ikh, int emcp_method_count);
 643 
 644   InstanceKlass* previous_versions() const { return _previous_versions; }
 645 
 646   InstanceKlass* get_klass_version(int version) {
 647     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 648       if (ik-&gt;constants()-&gt;version() == version) {
 649         return ik;
 650       }
 651     }
 652     return NULL;
 653   }
 654 
 655   bool has_been_redefined() const {
 656     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 657   }
 658   void set_has_been_redefined() {
 659     _misc_flags |= _misc_has_been_redefined;
 660   }
 661 
 662   bool is_scratch_class() const {
 663     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 664   }
 665 
 666   void set_is_scratch_class() {
 667     _misc_flags |= _misc_is_scratch_class;
 668   }
 669 
 670 private:
 671 
 672   void set_kind(unsigned kind) {
 673     assert(kind &lt;= _misc_kind_field_mask, "Invalid InstanceKlass kind");
 674     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 675     unsigned flags = _misc_flags &amp; ~fmask;
 676     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 677   }
 678 
 679   bool is_kind(unsigned desired) const {
 680     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 681     return kind == desired;
 682   }
 683 
 684 public:
 685 
 686   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 687   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 688   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 689   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 690   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
 691 
 692   void init_previous_versions() {
 693     _previous_versions = NULL;
 694   }
 695 
 696  private:
 697   static int  _previous_version_count;
 698  public:
 699   static void purge_previous_versions(InstanceKlass* ik);
 700   static bool has_previous_versions() { return _previous_version_count &gt; 0; }
 701 
 702   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 703   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 704     _cached_class_file = data;
 705   }
 706   JvmtiCachedClassFileData * get_cached_class_file() { return _cached_class_file; }
 707   jint get_cached_class_file_len();
 708   unsigned char * get_cached_class_file_bytes();
 709 
 710   // JVMTI: Support for caching of field indices, types, and offsets
 711   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 712     _jvmti_cached_class_field_map = descriptor;
 713   }
 714   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 715     return _jvmti_cached_class_field_map;
 716   }
 717 
 718   bool has_default_methods() const {
 719     return (_misc_flags &amp; _misc_has_default_methods) != 0;
 720   }
 721   void set_has_default_methods(bool b) {
 722     if (b) {
 723       _misc_flags |= _misc_has_default_methods;
 724     } else {
 725       _misc_flags &amp;= ~_misc_has_default_methods;
 726     }
 727   }
 728 
 729   bool declares_default_methods() const {
 730     return (_misc_flags &amp; _misc_declares_default_methods) != 0;
 731   }
 732   void set_declares_default_methods(bool b) {
 733     if (b) {
 734       _misc_flags |= _misc_declares_default_methods;
 735     } else {
 736       _misc_flags &amp;= ~_misc_declares_default_methods;
 737     }
 738   }
 739 
 740   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
 741   inline u2 next_method_idnum();
 742   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
 743 
 744   // generics support
 745   Symbol* generic_signature() const                   {
 746     return (_generic_signature_index == 0) ?
 747       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
 748   }
 749   u2 generic_signature_index() const                  {
 750     return _generic_signature_index;
 751   }
 752   void set_generic_signature_index(u2 sig_index)      {
 753     _generic_signature_index = sig_index;
 754   }
 755 
 756   u2 enclosing_method_data(int offset) const;
 757   u2 enclosing_method_class_index() const {
 758     return enclosing_method_data(enclosing_method_class_index_offset);
 759   }
 760   u2 enclosing_method_method_index() {
 761     return enclosing_method_data(enclosing_method_method_index_offset);
 762   }
 763   void set_enclosing_method_indices(u2 class_index,
 764                                     u2 method_index);
 765 
 766   // jmethodID support
 767   static jmethodID get_jmethod_id(instanceKlassHandle ik_h,
 768                      const methodHandle&amp; method_h);
 769   static jmethodID get_jmethod_id_fetch_or_update(instanceKlassHandle ik_h,
 770                      size_t idnum, jmethodID new_id, jmethodID* new_jmeths,
 771                      jmethodID* to_dealloc_id_p,
 772                      jmethodID** to_dealloc_jmeths_p);
 773   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
 774                 size_t *length_p, jmethodID* id_p);
 775   void ensure_space_for_methodids(int start_offset = 0);
 776   jmethodID jmethod_id_or_null(Method* method);
 777 
 778   // annotations support
 779   Annotations* annotations() const          { return _annotations; }
 780   void set_annotations(Annotations* anno)   { _annotations = anno; }
 781 
 782   AnnotationArray* class_annotations() const {
 783     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
 784   }
 785   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
 786     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
 787   }
 788   AnnotationArray* class_type_annotations() const {
 789     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
 790   }
 791   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
 792     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
 793   }
 794   // allocation
 795   instanceOop allocate_instance(TRAPS);
 796 
 797   // additional member function to return a handle
 798   instanceHandle allocate_instance_handle(TRAPS)      { return instanceHandle(THREAD, allocate_instance(THREAD)); }
 799 
 800   objArrayOop allocate_objArray(int n, int length, TRAPS);
 801   // Helper function
 802   static instanceOop register_finalizer(instanceOop i, TRAPS);
 803 
 804   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
 805   // if not, throw either an Error or an Exception.
 806   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
 807 
 808   // initialization
 809   void call_class_initializer(TRAPS);
 810   void set_initialization_state_and_notify(ClassState state, TRAPS);
 811 
 812   // OopMapCache support
 813   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
 814   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
 815   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
 816 
 817   // JNI identifier support (for static fields - for jni performance)
 818   JNIid* jni_ids()                               { return _jni_ids; }
 819   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
 820   JNIid* jni_id_for(int offset);
 821 
 822   // maintenance of deoptimization dependencies
 823   inline DependencyContext dependencies();
 824   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
 825   void add_dependent_nmethod(nmethod* nm);
 826   void remove_dependent_nmethod(nmethod* nm, bool delete_immediately);
 827 
 828   // On-stack replacement support
 829   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
 830   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
 831   void add_osr_nmethod(nmethod* n);
 832   void remove_osr_nmethod(nmethod* n);
 833   int mark_osr_nmethods(const Method* m);
 834   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
 835 
 836   // Breakpoint support (see methods on Method* for details)
 837   BreakpointInfo* breakpoints() const       { return _breakpoints; };
 838   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
 839 
 840   // support for stub routines
 841   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
 842   TRACE_DEFINE_KLASS_TRACE_ID_OFFSET;
 843   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
 844 
 845   // subclass/subinterface checks
 846   bool implements_interface(Klass* k) const;
 847   bool is_same_or_direct_interface(Klass* k) const;
 848 
 849 #ifdef ASSERT
 850   // check whether this class or one of its superclasses was redefined
 851   bool has_redefined_this_or_super() const;
 852 #endif
 853 
 854   // Access to the implementor of an interface.
 855   Klass* implementor() const
 856   {
 857     Klass** k = adr_implementor();
 858     if (k == NULL) {
 859       return NULL;
 860     } else {
 861       return *k;
 862     }
 863   }
 864 
 865   void set_implementor(Klass* k) {
 866     assert(is_interface(), "not interface");
 867     Klass** addr = adr_implementor();
 868     assert(addr != NULL, "null addr");
 869     if (addr != NULL) {
 870       *addr = k;
 871     }
 872   }
 873 
 874   int  nof_implementors() const       {
 875     Klass* k = implementor();
 876     if (k == NULL) {
 877       return 0;
 878     } else if (k != this) {
 879       return 1;
 880     } else {
 881       return 2;
 882     }
 883   }
 884 
 885   void add_implementor(Klass* k);  // k is a new class that implements this interface
 886   void init_implementor();           // initialize
 887 
 888   // link this class into the implementors list of every interface it implements
 889   void process_interfaces(Thread *thread);
 890 
 891   // virtual operations from Klass
 892   bool is_leaf_class() const               { return _subklass == NULL; }
 893   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots);
 894   bool compute_is_subtype_of(Klass* k);
 895   bool can_be_primary_super_slow() const;
 896   int oop_size(oop obj)  const             { return size_helper(); }
 897   // slow because it's a virtual call and used for verifying the layout_helper.
 898   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
 899   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
 900 
 901   // Iterators
 902   void do_local_static_fields(FieldClosure* cl);
 903   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
 904   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
 905 
 906   void methods_do(void f(Method* method));
 907   void array_klasses_do(void f(Klass* k));
 908   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
 909   bool super_types_do(SuperTypeClosure* blk);
 910 
 911   static InstanceKlass* cast(Klass* k) {
 912     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
 913   }
 914 
 915   static const InstanceKlass* cast(const Klass* k) {
 916     assert(k != NULL, "k should not be null");
 917     assert(k-&gt;is_instance_klass(), "cast to InstanceKlass");
 918     return static_cast&lt;const InstanceKlass*&gt;(k);
 919   }
 920 
 921   InstanceKlass* java_super() const {
 922     return (super() == NULL) ? NULL : cast(super());
 923   }
 924 
 925   // Sizing (in words)
 926   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
 927 
 928   static int size(int vtable_length, int itable_length,
 929                   int nonstatic_oop_map_size,
 930                   bool is_interface, bool is_anonymous) {
 931     return align_metadata_size(header_size() +
 932            vtable_length +
 933            itable_length +
 934            nonstatic_oop_map_size +
 935            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
 936            (is_anonymous ? (int)sizeof(Klass*)/wordSize : 0));
 937   }
 938   int size() const                    { return size(vtable_length(),
 939                                                itable_length(),
 940                                                nonstatic_oop_map_size(),
 941                                                is_interface(),
 942                                                is_anonymous());
 943   }
 944 #if INCLUDE_SERVICES
 945   virtual void collect_statistics(KlassSizeStats *sz) const;
 946 #endif
 947 
 948   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
 949   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
 950 
 951   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
 952 
 953   address static_field_addr(int offset);
 954 
 955   OopMapBlock* start_of_nonstatic_oop_maps() const {
 956     return (OopMapBlock*)(start_of_itable() + itable_length());
 957   }
 958 
 959   Klass** end_of_nonstatic_oop_maps() const {
 960     return (Klass**)(start_of_nonstatic_oop_maps() +
 961                      nonstatic_oop_map_count());
 962   }
 963 
 964   Klass** adr_implementor() const {
 965     if (is_interface()) {
 966       return (Klass**)end_of_nonstatic_oop_maps();
 967     } else {
 968       return NULL;
 969     }
 970   };
 971 
 972   Klass** adr_host_klass() const {
 973     if (is_anonymous()) {
 974       Klass** adr_impl = adr_implementor();
 975       if (adr_impl != NULL) {
 976         return adr_impl + 1;
 977       } else {
 978         return end_of_nonstatic_oop_maps();
 979       }
 980     } else {
 981       return NULL;
 982     }
 983   }
 984 
 985   // Use this to return the size of an instance in heap words:
 986   int size_helper() const {
 987     return layout_helper_to_size_helper(layout_helper());
 988   }
 989 
 990   // This bit is initialized in classFileParser.cpp.
 991   // It is false under any of the following conditions:
 992   //  - the class is abstract (including any interface)
 993   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
 994   //  - the class size is larger than FastAllocateSizeLimit
 995   //  - the class is java/lang/Class, which cannot be allocated directly
 996   bool can_be_fastpath_allocated() const {
 997     return !layout_helper_needs_slow_path(layout_helper());
 998   }
 999 
1000   // Java itable
1001   klassItable* itable() const;        // return new klassItable wrapper
1002   Method* method_at_itable(Klass* holder, int index, TRAPS);
1003 
1004 #if INCLUDE_JVMTI
1005   void adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed);
1006 #endif // INCLUDE_JVMTI
1007 
1008   void clean_weak_instanceklass_links(BoolObjectClosure* is_alive);
1009   void clean_implementors_list(BoolObjectClosure* is_alive);
1010   void clean_method_data(BoolObjectClosure* is_alive);
1011 
1012   // Explicit metaspace deallocation of fields
1013   // For RedefineClasses and class file parsing errors, we need to deallocate
1014   // instanceKlasses and the metadata they point to.
1015   void deallocate_contents(ClassLoaderData* loader_data);
1016   static void deallocate_methods(ClassLoaderData* loader_data,
1017                                  Array&lt;Method*&gt;* methods);
1018   void static deallocate_interfaces(ClassLoaderData* loader_data,
1019                                     const Klass* super_klass,
1020                                     Array&lt;Klass*&gt;* local_interfaces,
1021                                     Array&lt;Klass*&gt;* transitive_interfaces);
1022 
1023   // The constant pool is on stack if any of the methods are executing or
1024   // referenced by handles.
1025   bool on_stack() const { return _constants-&gt;on_stack(); }
1026 
1027   // callbacks for actions during class unloading
1028   static void notify_unload_class(InstanceKlass* ik);
1029   static void release_C_heap_structures(InstanceKlass* ik);
1030 
1031   // Naming
1032   const char* signature_name() const;
1033 
1034   // GC specific object visitors
1035   //
1036   // Mark Sweep
1037   int  oop_ms_adjust_pointers(oop obj);
1038 #if INCLUDE_ALL_GCS
1039   // Parallel Scavenge
1040   void oop_ps_push_contents(  oop obj, PSPromotionManager* pm);
1041   // Parallel Compact
1042   void oop_pc_follow_contents(oop obj, ParCompactionManager* cm);
1043   void oop_pc_update_pointers(oop obj, ParCompactionManager* cm);
1044 #endif
1045 
1046   // Oop fields (and metadata) iterators
1047   //  [nv = true]  Use non-virtual calls to do_oop_nv.
1048   //  [nv = false] Use virtual calls to do_oop.
1049   //
1050   // The InstanceKlass iterators also visits the Object's klass.
1051 
1052   // Forward iteration
1053  public:
1054   // Iterate over all oop fields in the oop maps.
1055   template &lt;bool nv, class OopClosureType&gt;
1056   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1057 
1058  protected:
1059   // Iterate over all oop fields and metadata.
1060   template &lt;bool nv, class OopClosureType&gt;
1061   inline int oop_oop_iterate(oop obj, OopClosureType* closure);
1062 
1063  private:
1064   // Iterate over all oop fields in the oop maps.
1065   // Specialized for [T = oop] or [T = narrowOop].
1066   template &lt;bool nv, typename T, class OopClosureType&gt;
1067   inline void oop_oop_iterate_oop_maps_specialized(oop obj, OopClosureType* closure);
1068 
1069   // Iterate over all oop fields in one oop map.
1070   template &lt;bool nv, typename T, class OopClosureType&gt;
1071   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1072 
1073 
1074   // Reverse iteration
1075 #if INCLUDE_ALL_GCS
1076  public:
1077   // Iterate over all oop fields in the oop maps.
1078   template &lt;bool nv, class OopClosureType&gt;
1079   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1080 
1081  protected:
1082   // Iterate over all oop fields and metadata.
1083   template &lt;bool nv, class OopClosureType&gt;
1084   inline int oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1085 
1086  private:
1087   // Iterate over all oop fields in the oop maps.
1088   // Specialized for [T = oop] or [T = narrowOop].
1089   template &lt;bool nv, typename T, class OopClosureType&gt;
1090   inline void oop_oop_iterate_oop_maps_specialized_reverse(oop obj, OopClosureType* closure);
1091 
1092   // Iterate over all oop fields in one oop map.
1093   template &lt;bool nv, typename T, class OopClosureType&gt;
1094   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1095 #endif
1096 
1097 
1098   // Bounded range iteration
1099  public:
1100   // Iterate over all oop fields in the oop maps.
1101   template &lt;bool nv, class OopClosureType&gt;
1102   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1103 
1104  protected:
1105   // Iterate over all oop fields and metadata.
1106   template &lt;bool nv, class OopClosureType&gt;
1107   inline int oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1108 
1109  private:
1110   // Iterate over all oop fields in the oop maps.
1111   // Specialized for [T = oop] or [T = narrowOop].
1112   template &lt;bool nv, typename T, class OopClosureType&gt;
1113   inline void oop_oop_iterate_oop_maps_specialized_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1114 
1115   // Iterate over all oop fields in one oop map.
1116   template &lt;bool nv, typename T, class OopClosureType&gt;
1117   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1118 
1119 
1120  public:
1121 
1122   ALL_OOP_OOP_ITERATE_CLOSURES_1(OOP_OOP_ITERATE_DECL)
1123   ALL_OOP_OOP_ITERATE_CLOSURES_2(OOP_OOP_ITERATE_DECL)
1124 
1125 #if INCLUDE_ALL_GCS
1126   ALL_OOP_OOP_ITERATE_CLOSURES_1(OOP_OOP_ITERATE_DECL_BACKWARDS)
1127   ALL_OOP_OOP_ITERATE_CLOSURES_2(OOP_OOP_ITERATE_DECL_BACKWARDS)
1128 #endif // INCLUDE_ALL_GCS
1129 
1130   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1131 
1132 public:
1133   void set_in_error_state() {
1134     assert(DumpSharedSpaces, "only call this when dumping archive");
1135     _init_state = initialization_error;
1136   }
1137   bool check_sharing_error_state();
1138 
1139 private:
1140   // initialization state
1141 #ifdef ASSERT
1142   void set_init_state(ClassState state);
1143 #else
1144   void set_init_state(ClassState state) { _init_state = (u1)state; }
1145 #endif
1146   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1147   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1148 
1149   // The RedefineClasses() API can cause new method idnums to be needed
1150   // which will cause the caches to grow. Safety requires different
1151   // cache management logic if the caches can grow instead of just
1152   // going from NULL to non-NULL.
1153   bool idnum_can_increment() const      { return has_been_redefined(); }
1154   jmethodID* methods_jmethod_ids_acquire() const
1155          { return (jmethodID*)OrderAccess::load_ptr_acquire(&amp;_methods_jmethod_ids); }
1156   void release_set_methods_jmethod_ids(jmethodID* jmeths)
1157          { OrderAccess::release_store_ptr(&amp;_methods_jmethod_ids, jmeths); }
1158 
1159   // Lock during initialization
1160 public:
1161   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1162   // Must be one per class and it has to be a VM internal object so java code
1163   // cannot lock it (like the mirror).
1164   // It has to be an object not a Mutex because it's held through java calls.
1165   oop init_lock() const;
1166 private:
1167   void fence_and_clear_init_lock();
1168 
1169   // Static methods that are used to implement member methods where an exposed this pointer
1170   // is needed due to possible GCs
1171   static bool link_class_impl                           (instanceKlassHandle this_k, bool throw_verifyerror, TRAPS);
1172   static bool verify_code                               (instanceKlassHandle this_k, bool throw_verifyerror, TRAPS);
1173   static void initialize_impl                           (instanceKlassHandle this_k, TRAPS);
1174   static void initialize_super_interfaces               (instanceKlassHandle this_k, TRAPS);
1175   static void eager_initialize_impl                     (instanceKlassHandle this_k);
1176   static void set_initialization_state_and_notify_impl  (instanceKlassHandle this_k, ClassState state, TRAPS);
1177   static void call_class_initializer_impl               (instanceKlassHandle this_k, TRAPS);
1178   static Klass* array_klass_impl                        (instanceKlassHandle this_k, bool or_null, int n, TRAPS);
1179   static void do_local_static_fields_impl               (instanceKlassHandle this_k, void f(fieldDescriptor* fd, Handle, TRAPS), Handle, TRAPS);
1180   /* jni_id_for_impl for jfieldID only */
1181   static JNIid* jni_id_for_impl                         (instanceKlassHandle this_k, int offset);
1182 
1183   // Returns the array class for the n'th dimension
1184   Klass* array_klass_impl(bool or_null, int n, TRAPS);
1185 
1186   // Returns the array class with this class as element type
1187   Klass* array_klass_impl(bool or_null, TRAPS);
1188 
1189   // find a local method (returns NULL if not found)
1190   Method* find_method_impl(const Symbol* name,
1191                            const Symbol* signature,
1192                            OverpassLookupMode overpass_mode,
1193                            StaticLookupMode static_mode,
1194                            PrivateLookupMode private_mode) const;
1195 
1196   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1197                                   const Symbol* name,
1198                                   const Symbol* signature,
1199                                   OverpassLookupMode overpass_mode,
1200                                   StaticLookupMode static_mode,
1201                                   PrivateLookupMode private_mode);
1202 
1203   // Free CHeap allocated fields.
1204   void release_C_heap_structures();
1205 
1206   // RedefineClasses support
1207   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1208   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1209 public:
1210   // CDS support - remove and restore oops from metadata. Oops are not shared.
1211   virtual void remove_unshareable_info();
1212   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
1213 
1214   // jvm support
1215   jint compute_modifier_flags(TRAPS) const;
1216 
1217   // JSR-292 support
1218   MemberNameTable* member_names() { return _member_names; }
1219   void set_member_names(MemberNameTable* member_names) { _member_names = member_names; }
1220   bool add_member_name(Handle member_name);
1221 
1222 public:
1223   // JVMTI support
1224   jint jvmti_class_status() const;
1225 
1226  public:
1227   // Printing
1228 #ifndef PRODUCT
1229   void print_on(outputStream* st) const;
1230 #endif
1231   void print_value_on(outputStream* st) const;
1232 
1233   void oop_print_value_on(oop obj, outputStream* st);
1234 
1235 #ifndef PRODUCT
1236   void oop_print_on      (oop obj, outputStream* st);
1237 
1238   void print_dependent_nmethods(bool verbose = false);
1239   bool is_dependent_nmethod(nmethod* nm);
1240 #endif
1241 
1242   const char* internal_name() const;
1243 
1244   // Verification
1245   void verify_on(outputStream* st);
1246 
1247   void oop_verify_on(oop obj, outputStream* st);
1248 
1249   // Logging
1250   void print_loading_log(LogLevel::type type, ClassLoaderData* loader_data, const ClassFileStream* cfs) const;
1251 };
1252 
1253 // for adding methods
1254 // UNSET_IDNUM return means no more ids available
1255 inline u2 InstanceKlass::next_method_idnum() {
1256   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1257     return ConstMethod::UNSET_IDNUM; // no more ids available
1258   } else {
1259     return _idnum_allocated_count++;
1260   }
1261 }
1262 
1263 
1264 /* JNIid class for jfieldIDs only */
1265 class JNIid: public CHeapObj&lt;mtClass&gt; {
1266   friend class VMStructs;
1267  private:
1268   Klass*             _holder;
1269   JNIid*             _next;
1270   int                _offset;
1271 #ifdef ASSERT
1272   bool               _is_static_field_id;
1273 #endif
1274 
1275  public:
1276   // Accessors
1277   Klass* holder() const           { return _holder; }
1278   int offset() const              { return _offset; }
1279   JNIid* next()                   { return _next; }
1280   // Constructor
1281   JNIid(Klass* holder, int offset, JNIid* next);
1282   // Identifier lookup
1283   JNIid* find(int offset);
1284 
1285   bool find_local_field(fieldDescriptor* fd) {
1286     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1287   }
1288 
1289   static void deallocate(JNIid* id);
1290   // Debugging
1291 #ifdef ASSERT
1292   bool is_static_field_id() const { return _is_static_field_id; }
1293   void set_is_static_field_id()   { _is_static_field_id = true; }
1294 #endif
1295   void verify(Klass* holder);
1296 };
1297 
1298 // An iterator that's used to access the inner classes indices in the
1299 // InstanceKlass::_inner_classes array.
1300 class InnerClassesIterator : public StackObj {
1301  private:
1302   Array&lt;jushort&gt;* _inner_classes;
1303   int _length;
1304   int _idx;
1305  public:
1306 
1307   InnerClassesIterator(instanceKlassHandle k) {
1308     _inner_classes = k-&gt;inner_classes();
1309     if (k-&gt;inner_classes() != NULL) {
1310       _length = _inner_classes-&gt;length();
1311       // The inner class array's length should be the multiple of
1312       // inner_class_next_offset if it only contains the InnerClasses
1313       // attribute data, or it should be
1314       // n*inner_class_next_offset+enclosing_method_attribute_size
1315       // if it also contains the EnclosingMethod data.
1316       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1317               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1318              "just checking");
1319       // Remove the enclosing_method portion if exists.
1320       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1321         _length -= InstanceKlass::enclosing_method_attribute_size;
1322       }
1323     } else {
1324       _length = 0;
1325     }
1326     _idx = 0;
1327   }
1328 
1329   int length() const {
1330     return _length;
1331   }
1332 
1333   void next() {
1334     _idx += InstanceKlass::inner_class_next_offset;
1335   }
1336 
1337   bool done() const {
1338     return (_idx &gt;= _length);
1339   }
1340 
1341   u2 inner_class_info_index() const {
1342     return _inner_classes-&gt;at(
1343                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1344   }
1345 
1346   void set_inner_class_info_index(u2 index) {
1347     _inner_classes-&gt;at_put(
1348                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1349   }
1350 
1351   u2 outer_class_info_index() const {
1352     return _inner_classes-&gt;at(
1353                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1354   }
1355 
1356   void set_outer_class_info_index(u2 index) {
1357     _inner_classes-&gt;at_put(
1358                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1359   }
1360 
1361   u2 inner_name_index() const {
1362     return _inner_classes-&gt;at(
1363                _idx + InstanceKlass::inner_class_inner_name_offset);
1364   }
1365 
1366   void set_inner_name_index(u2 index) {
1367     _inner_classes-&gt;at_put(
1368                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1369   }
1370 
1371   u2 inner_access_flags() const {
1372     return _inner_classes-&gt;at(
1373                _idx + InstanceKlass::inner_class_access_flags_offset);
1374   }
1375 };
1376 
1377 #endif // SHARE_VM_OOPS_INSTANCEKLASS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
