<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_VM_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include "classfile/classLoaderData.hpp"
  29 #include "gc/shared/specialized_oop_closures.hpp"
  30 #include "logging/logLevel.hpp"
  31 #include "memory/referenceType.hpp"
  32 #include "oops/annotations.hpp"
  33 #include "oops/constMethod.hpp"
  34 #include "oops/fieldInfo.hpp"
  35 #include "oops/instanceOop.hpp"
  36 #include "oops/klassVtable.hpp"
  37 #include "runtime/handles.hpp"
  38 #include "runtime/os.hpp"
  39 #include "trace/traceMacros.hpp"
  40 #include "utilities/accessFlags.hpp"
  41 #include "utilities/bitMap.inline.hpp"
  42 #include "utilities/macros.hpp"
  43 
  44 // An InstanceKlass is the VM level representation of a Java class.
  45 // It contains all information needed for at class at execution runtime.
  46 
  47 //  InstanceKlass embedded field layout (after declared fields):
  48 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  49 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  50 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  51 //      indicating where oops are located in instances of this klass.
  52 //    [EMBEDDED implementor of the interface] only exist for interface
  53 //    [EMBEDDED host klass        ] only exist for an anonymous class (JSR 292 enabled)
  54 
  55 
  56 // forward declaration for class -- see below for definition
  57 class BreakpointInfo;
  58 class ClassFileParser;
  59 class KlassDepChange;
  60 class DependencyContext;
  61 class fieldDescriptor;
  62 class jniIdMapBase;
  63 class JNIid;
  64 class JvmtiCachedClassFieldMap;
  65 class MemberNameTable;
  66 class SuperTypeClosure;
  67 
  68 // This is used in iterators below.
  69 class FieldClosure: public StackObj {
  70 public:
  71   virtual void do_field(fieldDescriptor* fd) = 0;
  72 };
  73 
  74 #ifndef PRODUCT
  75 // Print fields.
  76 // If "obj" argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  77 class FieldPrinter: public FieldClosure {
  78    oop _obj;
  79    outputStream* _st;
  80  public:
  81    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  82    void do_field(fieldDescriptor* fd);
  83 };
  84 #endif  // !PRODUCT
  85 
  86 // ValueObjs embedded in klass. Describes where oops are located in instances of
  87 // this klass.
  88 class OopMapBlock VALUE_OBJ_CLASS_SPEC {
  89  public:
  90   // Byte offset of the first oop mapped by this block.
  91   int offset() const          { return _offset; }
  92   void set_offset(int offset) { _offset = offset; }
  93 
  94   // Number of oops in this block.
  95   uint count() const         { return _count; }
  96   void set_count(uint count) { _count = count; }
  97 
  98   // sizeof(OopMapBlock) in words.
  99   static const int size_in_words() {
 100     return align_size_up(int(sizeof(OopMapBlock)), wordSize) &gt;&gt;
 101       LogBytesPerWord;
 102   }
 103 
 104  private:
 105   int  _offset;
 106   uint _count;
 107 };
 108 
 109 struct JvmtiCachedClassFileData;
 110 
 111 class InstanceKlass: public Klass {
 112   friend class VMStructs;
 113   friend class JVMCIVMStructs;
 114   friend class ClassFileParser;
 115   friend class CompileReplay;
<a name="1" id="anc1"></a><span class="new"> 116   friend class CacheCompileReplay;</span>
 117 
 118  protected:
 119   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind);
 120 
 121  public:
 122   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
 123 
 124   // See "The Java Virtual Machine Specification" section 2.16.2-5 for a detailed description
 125   // of the class loading &amp; initialization procedure, and the use of the states.
 126   enum ClassState {
 127     allocated,                          // allocated (but not yet linked)
 128     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 129     linked,                             // successfully linked/verified (but not initialized yet)
 130     being_initialized,                  // currently running class initializer
 131     fully_initialized,                  // initialized (successfull final state)
 132     initialization_error                // error happened during initialization
 133   };
 134 
 135   static int number_of_instance_classes() { return _total_instanceKlass_count; }
 136 
 137  private:
 138   static volatile int _total_instanceKlass_count;
 139   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 140 
 141  protected:
 142   // Annotations for this class
 143   Annotations*    _annotations;
 144   // Array classes holding elements of this class.
 145   Klass*          _array_klasses;
 146   // Constant pool for this class.
 147   ConstantPool* _constants;
 148   // The InnerClasses attribute and EnclosingMethod attribute. The
 149   // _inner_classes is an array of shorts. If the class has InnerClasses
 150   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 151   // [inner_class_info_index, outer_class_info_index,
 152   // inner_name_index, inner_class_access_flags] for the InnerClasses
 153   // attribute. If the EnclosingMethod attribute exists, it occupies the
 154   // last two shorts [class_index, method_index] of the array. If only
 155   // the InnerClasses attribute exists, the _inner_classes array length is
 156   // number_of_inner_classes * 4. If the class has both InnerClasses
 157   // and EnclosingMethod attributes the _inner_classes array length is
 158   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 159   Array&lt;jushort&gt;* _inner_classes;
 160 
 161   // the source debug extension for this klass, NULL if not specified.
 162   // Specified as UTF-8 string without terminating zero byte in the classfile,
 163   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 164   const char*     _source_debug_extension;
 165   // Array name derived from this class which needs unreferencing
 166   // if this class is unloaded.
 167   Symbol*         _array_name;
 168 
 169   // Number of heapOopSize words used by non-static fields in this klass
 170   // (including inherited fields but after header_size()).
 171   int             _nonstatic_field_size;
 172   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 173   // Constant pool index to the utf8 entry of the Generic signature,
 174   // or 0 if none.
 175   u2              _generic_signature_index;
 176   // Constant pool index to the utf8 entry for the name of source file
 177   // containing this klass, 0 if not specified.
 178   u2              _source_file_name_index;
 179   u2              _static_oop_field_count;// number of static oop fields in this klass
 180   u2              _java_fields_count;    // The number of declared Java fields
 181   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 182 
 183   int             _itable_len;           // length of Java itable (in words)
 184   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 185   // _misc_flags.
 186   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 187 
 188   // The low two bits of _misc_flags contains the kind field.
 189   // This can be used to quickly discriminate among the four kinds of
 190   // InstanceKlass.
 191 
 192   static const unsigned _misc_kind_field_size = 2;
 193   static const unsigned _misc_kind_field_pos  = 0;
 194   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 195 
 196   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 197   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 198   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 199   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 200 
 201   // Start after _misc_kind field.
 202   enum {
 203     _misc_rewritten                = 1 &lt;&lt; 2, // methods rewritten.
 204     _misc_has_nonstatic_fields     = 1 &lt;&lt; 3, // for sizing with UseCompressedOops
 205     _misc_should_verify_class      = 1 &lt;&lt; 4, // allow caching of preverification
 206     _misc_is_anonymous             = 1 &lt;&lt; 5, // has embedded _host_klass field
 207     _misc_is_contended             = 1 &lt;&lt; 6, // marked with contended annotation
 208     _misc_has_default_methods      = 1 &lt;&lt; 7, // class/superclass/implemented interfaces has default methods
 209     _misc_declares_default_methods = 1 &lt;&lt; 8, // directly declares default methods (any access)
 210     _misc_has_been_redefined       = 1 &lt;&lt; 9, // class has been redefined
 211     _misc_is_scratch_class         = 1 &lt;&lt; 10 // class is the redefined scratch class
 212   };
 213   u2              _misc_flags;
 214   u2              _minor_version;        // minor version number of class file
 215   u2              _major_version;        // major version number of class file
 216   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)
 217   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 218   MemberNameTable* _member_names;        // Member names
 219   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 220   jmethodID*      _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 221   intptr_t        _dep_context;          // packed DependencyContext structure
 222   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 223   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 224   // Linked instanceKlasses of previous versions
 225   InstanceKlass* _previous_versions;
 226   // JVMTI fields can be moved to their own structure - see 6315920
 227   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 228   JvmtiCachedClassFileData* _cached_class_file;
 229 
 230   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don't change
 231 
 232   // Class states are defined as ClassState (see above).
 233   // Place the _init_state here to utilize the unused 2-byte after
 234   // _idnum_allocated_count.
 235   u1              _init_state;                    // state of class
 236   u1              _reference_type;                // reference type
 237 
 238   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 239 
 240   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 241 
 242   // Method array.
 243   Array&lt;Method*&gt;* _methods;
 244   // Default Method Array, concrete methods inherited from interfaces
 245   Array&lt;Method*&gt;* _default_methods;
 246   // Interface (Klass*s) this class declares locally to implement.
 247   Array&lt;Klass*&gt;* _local_interfaces;
 248   // Interface (Klass*s) this class implements transitively.
 249   Array&lt;Klass*&gt;* _transitive_interfaces;
 250   // Int array containing the original order of method in the class file (for JVMTI).
 251   Array&lt;int&gt;*     _method_ordering;
 252   // Int array containing the vtable_indices for default_methods
 253   // offset matches _default_methods offset
 254   Array&lt;int&gt;*     _default_vtable_indices;
 255 
 256   // Instance and static variable information, starts with 6-tuples of shorts
 257   // [access, name index, sig index, initval index, low_offset, high_offset]
 258   // for all fields, followed by the generic signature data at the end of
 259   // the array. Only fields with generic signature attributes have the generic
 260   // signature data set in the array. The fields array looks like following:
 261   //
 262   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 263   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 264   //      ...
 265   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 266   //     [generic signature index]
 267   //     [generic signature index]
 268   //     ...
 269   Array&lt;u2&gt;*      _fields;
 270 
 271   // embedded Java vtable follows here
 272   // embedded Java itables follows here
 273   // embedded static fields follows here
 274   // embedded nonstatic oop-map blocks follows here
 275   // embedded implementor of this interface follows here
 276   //   The embedded implementor only exists if the current klass is an
 277   //   iterface. The possible values of the implementor fall into following
 278   //   three cases:
 279   //     NULL: no implementor.
 280   //     A Klass* that's not itself: one implementor.
 281   //     Itself: more than one implementors.
 282   // embedded host klass follows here
 283   //   The embedded host klass only exists in an anonymous class for
 284   //   dynamic language support (JSR 292 enabled). The host class grants
 285   //   its access privileges to this class also. The host class is either
 286   //   named, or a previously loaded anonymous class. A non-anonymous class
 287   //   or an anonymous class loaded through normal classloading does not
 288   //   have this embedded field.
 289   //
 290 
 291   friend class SystemDictionary;
 292 
 293  public:
 294   bool has_nonstatic_fields() const        {
 295     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 296   }
 297   void set_has_nonstatic_fields(bool b)    {
 298     if (b) {
 299       _misc_flags |= _misc_has_nonstatic_fields;
 300     } else {
 301       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 302     }
 303   }
 304 
 305   // field sizes
 306   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 307   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 308 
 309   int static_field_size() const            { return _static_field_size; }
 310   void set_static_field_size(int size)     { _static_field_size = size; }
 311 
 312   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 313   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 314 
 315   // Java itable
 316   int  itable_length() const               { return _itable_len; }
 317   void set_itable_length(int len)          { _itable_len = len; }
 318 
 319   // array klasses
 320   Klass* array_klasses() const             { return _array_klasses; }
 321   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 322 
 323   // methods
 324   Array&lt;Method*&gt;* methods() const          { return _methods; }
 325   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 326   Method* method_with_idnum(int idnum);
 327   Method* method_with_orig_idnum(int idnum);
 328   Method* method_with_orig_idnum(int idnum, int version);
 329 
 330   // method ordering
 331   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 332   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 333   void copy_method_ordering(const intArray* m, TRAPS);
 334 
 335   // default_methods
 336   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 337   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 338 
 339   // default method vtable_indices
 340   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 341   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 342   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 343 
 344   // interfaces
 345   Array&lt;Klass*&gt;* local_interfaces() const          { return _local_interfaces; }
 346   void set_local_interfaces(Array&lt;Klass*&gt;* a)      {
 347     guarantee(_local_interfaces == NULL || a == NULL, "Just checking");
 348     _local_interfaces = a; }
 349 
 350   Array&lt;Klass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 351   void set_transitive_interfaces(Array&lt;Klass*&gt;* a) {
 352     guarantee(_transitive_interfaces == NULL || a == NULL, "Just checking");
 353     _transitive_interfaces = a;
 354   }
 355 
 356  private:
 357   friend class fieldDescriptor;
 358   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 359 
 360  public:
 361   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 362   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 363   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 364   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 365 
 366   // Number of Java declared fields
 367   int java_fields_count() const           { return (int)_java_fields_count; }
 368 
 369   Array&lt;u2&gt;* fields() const            { return _fields; }
 370   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 371     guarantee(_fields == NULL || f == NULL, "Just checking");
 372     _fields = f;
 373     _java_fields_count = java_fields_count;
 374   }
 375 
 376   // inner classes
 377   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 378   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 379 
 380   enum InnerClassAttributeOffset {
 381     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 382     inner_class_inner_class_info_offset = 0,
 383     inner_class_outer_class_info_offset = 1,
 384     inner_class_inner_name_offset = 2,
 385     inner_class_access_flags_offset = 3,
 386     inner_class_next_offset = 4
 387   };
 388 
 389   enum EnclosingMethodAttributeOffset {
 390     enclosing_method_class_index_offset = 0,
 391     enclosing_method_method_index_offset = 1,
 392     enclosing_method_attribute_size = 2
 393   };
 394 
 395   // method override check
 396   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 397 
 398   // package
 399   bool is_same_class_package(const Klass* class2) const;
 400   bool is_same_class_package(oop classloader2, const Symbol* classname2) const;
 401   static bool is_same_class_package(oop class_loader1,
 402                                     const Symbol* class_name1,
 403                                     oop class_loader2,
 404                                     const Symbol* class_name2);
 405 
 406   // find an enclosing class
 407   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const {
 408     return compute_enclosing_class_impl(this, inner_is_member, THREAD);
 409   }
 410   static InstanceKlass* compute_enclosing_class_impl(const InstanceKlass* self,
 411                                                      bool* inner_is_member,
 412                                                      TRAPS);
 413 
 414   // Find InnerClasses attribute for k and return outer_class_info_index &amp; inner_name_index.
 415   static bool find_inner_classes_attr(instanceKlassHandle k,
 416                                       int* ooff, int* noff, TRAPS);
 417 
 418   // tell if two classes have the same enclosing class (at package level)
 419   bool is_same_package_member(const Klass* class2, TRAPS) const {
 420     return is_same_package_member_impl(this, class2, THREAD);
 421   }
 422   static bool is_same_package_member_impl(const InstanceKlass* self,
 423                                           const Klass* class2,
 424                                           TRAPS);
 425 
 426   // initialization state
 427   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 428   bool is_linked() const                   { return _init_state &gt;= linked; }
 429   bool is_initialized() const              { return _init_state == fully_initialized; }
 430   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 431   bool is_being_initialized() const        { return _init_state == being_initialized; }
 432   bool is_in_error_state() const           { return _init_state == initialization_error; }
 433   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 434   ClassState  init_state()                 { return (ClassState)_init_state; }
 435   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 436 
 437   // defineClass specified verification
 438   bool should_verify_class() const         {
 439     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 440   }
 441   void set_should_verify_class(bool value) {
 442     if (value) {
 443       _misc_flags |= _misc_should_verify_class;
 444     } else {
 445       _misc_flags &amp;= ~_misc_should_verify_class;
 446     }
 447   }
 448 
 449   // marking
 450   bool is_marked_dependent() const         { return _is_marked_dependent; }
 451   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 452 
 453   // initialization (virtuals from Klass)
 454   bool should_be_initialized() const;  // means that initialize should be called
 455   void initialize(TRAPS);
 456   void link_class(TRAPS);
 457   bool link_class_or_fail(TRAPS); // returns false on failure
 458   void unlink_class();
 459   void rewrite_class(TRAPS);
 460   void link_methods(TRAPS);
 461   Method* class_initializer();
 462 
 463   // set the class to initialized if no static initializer is present
 464   void eager_initialize(Thread *thread);
 465 
 466   // reference type
 467   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 468   void set_reference_type(ReferenceType t) {
 469     assert(t == (u1)t, "overflow");
 470     _reference_type = (u1)t;
 471   }
 472 
 473   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 474 
 475   // find local field, returns true if found
 476   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 477   // find field in direct superinterfaces, returns the interface in which the field is defined
 478   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 479   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 480   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 481   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 482   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 483 
 484   // find a non-static or static field given its offset within the class.
 485   bool contains_field_offset(int offset) {
 486     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());
 487   }
 488 
 489   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 490   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 491 
 492   // find a local method (returns NULL if not found)
 493   Method* find_method(const Symbol* name, const Symbol* signature) const;
 494   static Method* find_method(const Array&lt;Method*&gt;* methods,
 495                              const Symbol* name,
 496                              const Symbol* signature);
 497 
 498   // find a local method, but skip static methods
 499   Method* find_instance_method(const Symbol* name, const Symbol* signature) const;
 500   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 501                                       const Symbol* name,
 502                                       const Symbol* signature);
 503 
 504   // find a local method (returns NULL if not found)
 505   Method* find_local_method(const Symbol* name,
 506                             const Symbol* signature,
 507                             OverpassLookupMode overpass_mode,
 508                             StaticLookupMode static_mode,
 509                             PrivateLookupMode private_mode) const;
 510 
 511   // find a local method from given methods array (returns NULL if not found)
 512   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 513                                    const Symbol* name,
 514                                    const Symbol* signature,
 515                                    OverpassLookupMode overpass_mode,
 516                                    StaticLookupMode static_mode,
 517                                    PrivateLookupMode private_mode);
 518 
 519   // find a local method index in methods or default_methods (returns -1 if not found)
 520   static int find_method_index(const Array&lt;Method*&gt;* methods,
 521                                const Symbol* name,
 522                                const Symbol* signature,
 523                                OverpassLookupMode overpass_mode,
 524                                StaticLookupMode static_mode,
 525                                PrivateLookupMode private_mode);
 526 
 527   // lookup operation (returns NULL if not found)
 528   Method* uncached_lookup_method(const Symbol* name,
 529                                  const Symbol* signature,
 530                                  OverpassLookupMode overpass_mode) const;
 531 
 532   // lookup a method in all the interfaces that this class implements
 533   // (returns NULL if not found)
 534   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 535 
 536   // lookup a method in local defaults then in all interfaces
 537   // (returns NULL if not found)
 538   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 539 
 540   // Find method indices by name.  If a method with the specified name is
 541   // found the index to the first method is returned, and 'end' is filled in
 542   // with the index of first non-name-matching method.  If no method is found
 543   // -1 is returned.
 544   int find_method_by_name(const Symbol* name, int* end) const;
 545   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 546                                  const Symbol* name, int* end);
 547 
 548   // constant pool
 549   ConstantPool* constants() const        { return _constants; }
 550   void set_constants(ConstantPool* c)    { _constants = c; }
 551 
 552   // protection domain
 553   oop protection_domain() const;
 554 
 555   // signers
 556   objArrayOop signers() const;
 557 
 558   // host class
 559   Klass* host_klass() const              {
 560     Klass** hk = (Klass**)adr_host_klass();
 561     if (hk == NULL) {
 562       return NULL;
 563     } else {
 564       assert(*hk != NULL, "host klass should always be set if the address is not null");
 565       return *hk;
 566     }
 567   }
 568   void set_host_klass(const Klass* host) {
 569     assert(is_anonymous(), "not anonymous");
 570     const Klass** addr = (const Klass**)adr_host_klass();
 571     assert(addr != NULL, "no reversed space");
 572     if (addr != NULL) {
 573       *addr = host;
 574     }
 575   }
 576   bool is_anonymous() const                {
 577     return (_misc_flags &amp; _misc_is_anonymous) != 0;
 578   }
 579   void set_is_anonymous(bool value)        {
 580     if (value) {
 581       _misc_flags |= _misc_is_anonymous;
 582     } else {
 583       _misc_flags &amp;= ~_misc_is_anonymous;
 584     }
 585   }
 586 
 587   // Oop that keeps the metadata for this class from being unloaded
 588   // in places where the metadata is stored in other places, like nmethods
 589   oop klass_holder() const {
 590     return is_anonymous() ? java_mirror() : class_loader();
 591   }
 592 
 593   bool is_contended() const                {
 594     return (_misc_flags &amp; _misc_is_contended) != 0;
 595   }
 596   void set_is_contended(bool value)        {
 597     if (value) {
 598       _misc_flags |= _misc_is_contended;
 599     } else {
 600       _misc_flags &amp;= ~_misc_is_contended;
 601     }
 602   }
 603 
 604   // source file name
 605   Symbol* source_file_name() const               {
 606     return (_source_file_name_index == 0) ?
 607       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 608   }
 609   u2 source_file_name_index() const              {
 610     return _source_file_name_index;
 611   }
 612   void set_source_file_name_index(u2 sourcefile_index) {
 613     _source_file_name_index = sourcefile_index;
 614   }
 615 
 616   // minor and major version numbers of class file
 617   u2 minor_version() const                 { return _minor_version; }
 618   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 619   u2 major_version() const                 { return _major_version; }
 620   void set_major_version(u2 major_version) { _major_version = major_version; }
 621 
 622   // source debug extension
 623   const char* source_debug_extension() const { return _source_debug_extension; }
 624   void set_source_debug_extension(const char* array, int length);
 625 
 626   // symbol unloading support (refcount already added)
 627   Symbol* array_name()                     { return _array_name; }
 628   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, "name already created"); _array_name = name; }
 629 
 630   // nonstatic oop-map blocks
 631   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 632     return oop_map_count * OopMapBlock::size_in_words();
 633   }
 634   unsigned int nonstatic_oop_map_count() const {
 635     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 636   }
 637   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 638   void set_nonstatic_oop_map_size(int words) {
 639     _nonstatic_oop_map_size = words;
 640   }
 641 
 642   // RedefineClasses() support for previous versions:
 643   void add_previous_version(instanceKlassHandle ikh, int emcp_method_count);
 644 
 645   InstanceKlass* previous_versions() const { return _previous_versions; }
 646 
 647   InstanceKlass* get_klass_version(int version) {
 648     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 649       if (ik-&gt;constants()-&gt;version() == version) {
 650         return ik;
 651       }
 652     }
 653     return NULL;
 654   }
 655 
 656   bool has_been_redefined() const {
 657     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 658   }
 659   void set_has_been_redefined() {
 660     _misc_flags |= _misc_has_been_redefined;
 661   }
 662 
 663   bool is_scratch_class() const {
 664     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 665   }
 666 
 667   void set_is_scratch_class() {
 668     _misc_flags |= _misc_is_scratch_class;
 669   }
 670 
 671 private:
 672 
 673   void set_kind(unsigned kind) {
 674     assert(kind &lt;= _misc_kind_field_mask, "Invalid InstanceKlass kind");
 675     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 676     unsigned flags = _misc_flags &amp; ~fmask;
 677     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 678   }
 679 
 680   bool is_kind(unsigned desired) const {
 681     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 682     return kind == desired;
 683   }
 684 
 685 public:
 686 
 687   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 688   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 689   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 690   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 691   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
 692 
 693   void init_previous_versions() {
 694     _previous_versions = NULL;
 695   }
 696 
 697  private:
 698   static int  _previous_version_count;
 699  public:
 700   static void purge_previous_versions(InstanceKlass* ik);
 701   static bool has_previous_versions() { return _previous_version_count &gt; 0; }
 702 
 703   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 704   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 705     _cached_class_file = data;
 706   }
 707   JvmtiCachedClassFileData * get_cached_class_file() { return _cached_class_file; }
 708   jint get_cached_class_file_len();
 709   unsigned char * get_cached_class_file_bytes();
 710 
 711   // JVMTI: Support for caching of field indices, types, and offsets
 712   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 713     _jvmti_cached_class_field_map = descriptor;
 714   }
 715   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 716     return _jvmti_cached_class_field_map;
 717   }
 718 
 719   bool has_default_methods() const {
 720     return (_misc_flags &amp; _misc_has_default_methods) != 0;
 721   }
 722   void set_has_default_methods(bool b) {
 723     if (b) {
 724       _misc_flags |= _misc_has_default_methods;
 725     } else {
 726       _misc_flags &amp;= ~_misc_has_default_methods;
 727     }
 728   }
 729 
 730   bool declares_default_methods() const {
 731     return (_misc_flags &amp; _misc_declares_default_methods) != 0;
 732   }
 733   void set_declares_default_methods(bool b) {
 734     if (b) {
 735       _misc_flags |= _misc_declares_default_methods;
 736     } else {
 737       _misc_flags &amp;= ~_misc_declares_default_methods;
 738     }
 739   }
 740 
 741   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
 742   inline u2 next_method_idnum();
 743   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
 744 
 745   // generics support
 746   Symbol* generic_signature() const                   {
 747     return (_generic_signature_index == 0) ?
 748       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
 749   }
 750   u2 generic_signature_index() const                  {
 751     return _generic_signature_index;
 752   }
 753   void set_generic_signature_index(u2 sig_index)      {
 754     _generic_signature_index = sig_index;
 755   }
 756 
 757   u2 enclosing_method_data(int offset) const;
 758   u2 enclosing_method_class_index() const {
 759     return enclosing_method_data(enclosing_method_class_index_offset);
 760   }
 761   u2 enclosing_method_method_index() {
 762     return enclosing_method_data(enclosing_method_method_index_offset);
 763   }
 764   void set_enclosing_method_indices(u2 class_index,
 765                                     u2 method_index);
 766 
 767   // jmethodID support
 768   static jmethodID get_jmethod_id(instanceKlassHandle ik_h,
 769                      const methodHandle&amp; method_h);
 770   static jmethodID get_jmethod_id_fetch_or_update(instanceKlassHandle ik_h,
 771                      size_t idnum, jmethodID new_id, jmethodID* new_jmeths,
 772                      jmethodID* to_dealloc_id_p,
 773                      jmethodID** to_dealloc_jmeths_p);
 774   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
 775                 size_t *length_p, jmethodID* id_p);
 776   void ensure_space_for_methodids(int start_offset = 0);
 777   jmethodID jmethod_id_or_null(Method* method);
 778 
 779   // annotations support
 780   Annotations* annotations() const          { return _annotations; }
 781   void set_annotations(Annotations* anno)   { _annotations = anno; }
 782 
 783   AnnotationArray* class_annotations() const {
 784     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
 785   }
 786   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
 787     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
 788   }
 789   AnnotationArray* class_type_annotations() const {
 790     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
 791   }
 792   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
 793     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
 794   }
 795   // allocation
 796   instanceOop allocate_instance(TRAPS);
 797 
 798   // additional member function to return a handle
 799   instanceHandle allocate_instance_handle(TRAPS)      { return instanceHandle(THREAD, allocate_instance(THREAD)); }
 800 
 801   objArrayOop allocate_objArray(int n, int length, TRAPS);
 802   // Helper function
 803   static instanceOop register_finalizer(instanceOop i, TRAPS);
 804 
 805   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
 806   // if not, throw either an Error or an Exception.
 807   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
 808 
 809   // initialization
 810   void call_class_initializer(TRAPS);
 811   void set_initialization_state_and_notify(ClassState state, TRAPS);
 812 
 813   // OopMapCache support
 814   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
 815   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
 816   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
 817 
 818   // JNI identifier support (for static fields - for jni performance)
 819   JNIid* jni_ids()                               { return _jni_ids; }
 820   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
 821   JNIid* jni_id_for(int offset);
 822 
 823   // maintenance of deoptimization dependencies
 824   inline DependencyContext dependencies();
 825   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
 826   void add_dependent_nmethod(nmethod* nm);
 827   void remove_dependent_nmethod(nmethod* nm, bool delete_immediately);
 828 
 829   // On-stack replacement support
 830   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
 831   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
 832   void add_osr_nmethod(nmethod* n);
 833   void remove_osr_nmethod(nmethod* n);
 834   int mark_osr_nmethods(const Method* m);
 835   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
 836 
 837   // Breakpoint support (see methods on Method* for details)
 838   BreakpointInfo* breakpoints() const       { return _breakpoints; };
 839   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
 840 
 841   // support for stub routines
 842   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
 843   TRACE_DEFINE_KLASS_TRACE_ID_OFFSET;
 844   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
 845 
 846   // subclass/subinterface checks
 847   bool implements_interface(Klass* k) const;
 848   bool is_same_or_direct_interface(Klass* k) const;
 849 
 850 #ifdef ASSERT
 851   // check whether this class or one of its superclasses was redefined
 852   bool has_redefined_this_or_super() const;
 853 #endif
 854 
 855   // Access to the implementor of an interface.
 856   Klass* implementor() const
 857   {
 858     Klass** k = adr_implementor();
 859     if (k == NULL) {
 860       return NULL;
 861     } else {
 862       return *k;
 863     }
 864   }
 865 
 866   void set_implementor(Klass* k) {
 867     assert(is_interface(), "not interface");
 868     Klass** addr = adr_implementor();
 869     assert(addr != NULL, "null addr");
 870     if (addr != NULL) {
 871       *addr = k;
 872     }
 873   }
 874 
 875   int  nof_implementors() const       {
 876     Klass* k = implementor();
 877     if (k == NULL) {
 878       return 0;
 879     } else if (k != this) {
 880       return 1;
 881     } else {
 882       return 2;
 883     }
 884   }
 885 
 886   void add_implementor(Klass* k);  // k is a new class that implements this interface
 887   void init_implementor();           // initialize
 888 
 889   // link this class into the implementors list of every interface it implements
 890   void process_interfaces(Thread *thread);
 891 
 892   // virtual operations from Klass
 893   bool is_leaf_class() const               { return _subklass == NULL; }
 894   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots);
 895   bool compute_is_subtype_of(Klass* k);
 896   bool can_be_primary_super_slow() const;
 897   int oop_size(oop obj)  const             { return size_helper(); }
 898   // slow because it's a virtual call and used for verifying the layout_helper.
 899   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
 900   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
 901 
 902   // Iterators
 903   void do_local_static_fields(FieldClosure* cl);
 904   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
 905   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
 906 
 907   void methods_do(void f(Method* method));
 908   void array_klasses_do(void f(Klass* k));
 909   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
 910   bool super_types_do(SuperTypeClosure* blk);
 911 
 912   static InstanceKlass* cast(Klass* k) {
 913     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
 914   }
 915 
 916   static const InstanceKlass* cast(const Klass* k) {
 917     assert(k != NULL, "k should not be null");
 918     assert(k-&gt;is_instance_klass(), "cast to InstanceKlass");
 919     return static_cast&lt;const InstanceKlass*&gt;(k);
 920   }
 921 
 922   InstanceKlass* java_super() const {
 923     return (super() == NULL) ? NULL : cast(super());
 924   }
 925 
 926   // Sizing (in words)
 927   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
 928 
 929   static int size(int vtable_length, int itable_length,
 930                   int nonstatic_oop_map_size,
 931                   bool is_interface, bool is_anonymous) {
 932     return align_metadata_size(header_size() +
 933            vtable_length +
 934            itable_length +
 935            nonstatic_oop_map_size +
 936            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
 937            (is_anonymous ? (int)sizeof(Klass*)/wordSize : 0));
 938   }
 939   int size() const                    { return size(vtable_length(),
 940                                                itable_length(),
 941                                                nonstatic_oop_map_size(),
 942                                                is_interface(),
 943                                                is_anonymous());
 944   }
 945 #if INCLUDE_SERVICES
 946   virtual void collect_statistics(KlassSizeStats *sz) const;
 947 #endif
 948 
 949   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
 950   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
 951 
 952   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
 953 
 954   address static_field_addr(int offset);
 955 
 956   OopMapBlock* start_of_nonstatic_oop_maps() const {
 957     return (OopMapBlock*)(start_of_itable() + itable_length());
 958   }
 959 
 960   Klass** end_of_nonstatic_oop_maps() const {
 961     return (Klass**)(start_of_nonstatic_oop_maps() +
 962                      nonstatic_oop_map_count());
 963   }
 964 
 965   Klass** adr_implementor() const {
 966     if (is_interface()) {
 967       return (Klass**)end_of_nonstatic_oop_maps();
 968     } else {
 969       return NULL;
 970     }
 971   };
 972 
 973   Klass** adr_host_klass() const {
 974     if (is_anonymous()) {
 975       Klass** adr_impl = adr_implementor();
 976       if (adr_impl != NULL) {
 977         return adr_impl + 1;
 978       } else {
 979         return end_of_nonstatic_oop_maps();
 980       }
 981     } else {
 982       return NULL;
 983     }
 984   }
 985 
 986   // Use this to return the size of an instance in heap words:
 987   int size_helper() const {
 988     return layout_helper_to_size_helper(layout_helper());
 989   }
 990 
 991   // This bit is initialized in classFileParser.cpp.
 992   // It is false under any of the following conditions:
 993   //  - the class is abstract (including any interface)
 994   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
 995   //  - the class size is larger than FastAllocateSizeLimit
 996   //  - the class is java/lang/Class, which cannot be allocated directly
 997   bool can_be_fastpath_allocated() const {
 998     return !layout_helper_needs_slow_path(layout_helper());
 999   }
1000 
1001   // Java itable
1002   klassItable* itable() const;        // return new klassItable wrapper
1003   Method* method_at_itable(Klass* holder, int index, TRAPS);
1004 
1005 #if INCLUDE_JVMTI
1006   void adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed);
1007 #endif // INCLUDE_JVMTI
1008 
1009   void clean_weak_instanceklass_links(BoolObjectClosure* is_alive);
1010   void clean_implementors_list(BoolObjectClosure* is_alive);
1011   void clean_method_data(BoolObjectClosure* is_alive);
1012 
1013   // Explicit metaspace deallocation of fields
1014   // For RedefineClasses and class file parsing errors, we need to deallocate
1015   // instanceKlasses and the metadata they point to.
1016   void deallocate_contents(ClassLoaderData* loader_data);
1017   static void deallocate_methods(ClassLoaderData* loader_data,
1018                                  Array&lt;Method*&gt;* methods);
1019   void static deallocate_interfaces(ClassLoaderData* loader_data,
1020                                     const Klass* super_klass,
1021                                     Array&lt;Klass*&gt;* local_interfaces,
1022                                     Array&lt;Klass*&gt;* transitive_interfaces);
1023 
1024   // The constant pool is on stack if any of the methods are executing or
1025   // referenced by handles.
1026   bool on_stack() const { return _constants-&gt;on_stack(); }
1027 
1028   // callbacks for actions during class unloading
1029   static void notify_unload_class(InstanceKlass* ik);
1030   static void release_C_heap_structures(InstanceKlass* ik);
1031 
1032   // Naming
1033   const char* signature_name() const;
1034 
1035   // GC specific object visitors
1036   //
1037   // Mark Sweep
1038   int  oop_ms_adjust_pointers(oop obj);
1039 #if INCLUDE_ALL_GCS
1040   // Parallel Scavenge
1041   void oop_ps_push_contents(  oop obj, PSPromotionManager* pm);
1042   // Parallel Compact
1043   void oop_pc_follow_contents(oop obj, ParCompactionManager* cm);
1044   void oop_pc_update_pointers(oop obj, ParCompactionManager* cm);
1045 #endif
1046 
1047   // Oop fields (and metadata) iterators
1048   //  [nv = true]  Use non-virtual calls to do_oop_nv.
1049   //  [nv = false] Use virtual calls to do_oop.
1050   //
1051   // The InstanceKlass iterators also visits the Object's klass.
1052 
1053   // Forward iteration
1054  public:
1055   // Iterate over all oop fields in the oop maps.
1056   template &lt;bool nv, class OopClosureType&gt;
1057   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1058 
1059  protected:
1060   // Iterate over all oop fields and metadata.
1061   template &lt;bool nv, class OopClosureType&gt;
1062   inline int oop_oop_iterate(oop obj, OopClosureType* closure);
1063 
1064  private:
1065   // Iterate over all oop fields in the oop maps.
1066   // Specialized for [T = oop] or [T = narrowOop].
1067   template &lt;bool nv, typename T, class OopClosureType&gt;
1068   inline void oop_oop_iterate_oop_maps_specialized(oop obj, OopClosureType* closure);
1069 
1070   // Iterate over all oop fields in one oop map.
1071   template &lt;bool nv, typename T, class OopClosureType&gt;
1072   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1073 
1074 
1075   // Reverse iteration
1076 #if INCLUDE_ALL_GCS
1077  public:
1078   // Iterate over all oop fields in the oop maps.
1079   template &lt;bool nv, class OopClosureType&gt;
1080   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1081 
1082  protected:
1083   // Iterate over all oop fields and metadata.
1084   template &lt;bool nv, class OopClosureType&gt;
1085   inline int oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1086 
1087  private:
1088   // Iterate over all oop fields in the oop maps.
1089   // Specialized for [T = oop] or [T = narrowOop].
1090   template &lt;bool nv, typename T, class OopClosureType&gt;
1091   inline void oop_oop_iterate_oop_maps_specialized_reverse(oop obj, OopClosureType* closure);
1092 
1093   // Iterate over all oop fields in one oop map.
1094   template &lt;bool nv, typename T, class OopClosureType&gt;
1095   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1096 #endif
1097 
1098 
1099   // Bounded range iteration
1100  public:
1101   // Iterate over all oop fields in the oop maps.
1102   template &lt;bool nv, class OopClosureType&gt;
1103   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1104 
1105  protected:
1106   // Iterate over all oop fields and metadata.
1107   template &lt;bool nv, class OopClosureType&gt;
1108   inline int oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1109 
1110  private:
1111   // Iterate over all oop fields in the oop maps.
1112   // Specialized for [T = oop] or [T = narrowOop].
1113   template &lt;bool nv, typename T, class OopClosureType&gt;
1114   inline void oop_oop_iterate_oop_maps_specialized_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1115 
1116   // Iterate over all oop fields in one oop map.
1117   template &lt;bool nv, typename T, class OopClosureType&gt;
1118   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1119 
1120 
1121  public:
1122 
1123   ALL_OOP_OOP_ITERATE_CLOSURES_1(OOP_OOP_ITERATE_DECL)
1124   ALL_OOP_OOP_ITERATE_CLOSURES_2(OOP_OOP_ITERATE_DECL)
1125 
1126 #if INCLUDE_ALL_GCS
1127   ALL_OOP_OOP_ITERATE_CLOSURES_1(OOP_OOP_ITERATE_DECL_BACKWARDS)
1128   ALL_OOP_OOP_ITERATE_CLOSURES_2(OOP_OOP_ITERATE_DECL_BACKWARDS)
1129 #endif // INCLUDE_ALL_GCS
1130 
1131   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1132 
1133 public:
1134   void set_in_error_state() {
1135     assert(DumpSharedSpaces, "only call this when dumping archive");
1136     _init_state = initialization_error;
1137   }
1138   bool check_sharing_error_state();
1139 
1140 private:
1141   // initialization state
1142 #ifdef ASSERT
1143   void set_init_state(ClassState state);
1144 #else
1145   void set_init_state(ClassState state) { _init_state = (u1)state; }
1146 #endif
1147   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1148   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1149 
1150   // The RedefineClasses() API can cause new method idnums to be needed
1151   // which will cause the caches to grow. Safety requires different
1152   // cache management logic if the caches can grow instead of just
1153   // going from NULL to non-NULL.
1154   bool idnum_can_increment() const      { return has_been_redefined(); }
1155   jmethodID* methods_jmethod_ids_acquire() const
1156          { return (jmethodID*)OrderAccess::load_ptr_acquire(&amp;_methods_jmethod_ids); }
1157   void release_set_methods_jmethod_ids(jmethodID* jmeths)
1158          { OrderAccess::release_store_ptr(&amp;_methods_jmethod_ids, jmeths); }
1159 
1160   // Lock during initialization
1161 public:
1162   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1163   // Must be one per class and it has to be a VM internal object so java code
1164   // cannot lock it (like the mirror).
1165   // It has to be an object not a Mutex because it's held through java calls.
1166   oop init_lock() const;
1167 private:
1168   void fence_and_clear_init_lock();
1169 
1170   // Static methods that are used to implement member methods where an exposed this pointer
1171   // is needed due to possible GCs
1172   static bool link_class_impl                           (instanceKlassHandle this_k, bool throw_verifyerror, TRAPS);
1173   static bool verify_code                               (instanceKlassHandle this_k, bool throw_verifyerror, TRAPS);
1174   static void initialize_impl                           (instanceKlassHandle this_k, TRAPS);
1175   static void initialize_super_interfaces               (instanceKlassHandle this_k, TRAPS);
1176   static void eager_initialize_impl                     (instanceKlassHandle this_k);
1177   static void set_initialization_state_and_notify_impl  (instanceKlassHandle this_k, ClassState state, TRAPS);
1178   static void call_class_initializer_impl               (instanceKlassHandle this_k, TRAPS);
1179   static Klass* array_klass_impl                        (instanceKlassHandle this_k, bool or_null, int n, TRAPS);
1180   static void do_local_static_fields_impl               (instanceKlassHandle this_k, void f(fieldDescriptor* fd, Handle, TRAPS), Handle, TRAPS);
1181   /* jni_id_for_impl for jfieldID only */
1182   static JNIid* jni_id_for_impl                         (instanceKlassHandle this_k, int offset);
1183 
1184   // Returns the array class for the n'th dimension
1185   Klass* array_klass_impl(bool or_null, int n, TRAPS);
1186 
1187   // Returns the array class with this class as element type
1188   Klass* array_klass_impl(bool or_null, TRAPS);
1189 
1190   // find a local method (returns NULL if not found)
1191   Method* find_method_impl(const Symbol* name,
1192                            const Symbol* signature,
1193                            OverpassLookupMode overpass_mode,
1194                            StaticLookupMode static_mode,
1195                            PrivateLookupMode private_mode) const;
1196 
1197   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1198                                   const Symbol* name,
1199                                   const Symbol* signature,
1200                                   OverpassLookupMode overpass_mode,
1201                                   StaticLookupMode static_mode,
1202                                   PrivateLookupMode private_mode);
1203 
1204   // Free CHeap allocated fields.
1205   void release_C_heap_structures();
1206 
1207   // RedefineClasses support
1208   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1209   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1210 public:
1211   // CDS support - remove and restore oops from metadata. Oops are not shared.
1212   virtual void remove_unshareable_info();
1213   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
1214 
1215   // jvm support
1216   jint compute_modifier_flags(TRAPS) const;
1217 
1218   // JSR-292 support
1219   MemberNameTable* member_names() { return _member_names; }
1220   void set_member_names(MemberNameTable* member_names) { _member_names = member_names; }
1221   bool add_member_name(Handle member_name);
1222 
1223 public:
1224   // JVMTI support
1225   jint jvmti_class_status() const;
1226 
1227  public:
1228   // Printing
1229 #ifndef PRODUCT
1230   void print_on(outputStream* st) const;
1231 #endif
1232   void print_value_on(outputStream* st) const;
1233 
1234   void oop_print_value_on(oop obj, outputStream* st);
1235 
1236 #ifndef PRODUCT
1237   void oop_print_on      (oop obj, outputStream* st);
1238 
1239   void print_dependent_nmethods(bool verbose = false);
1240   bool is_dependent_nmethod(nmethod* nm);
1241 #endif
1242 
1243   const char* internal_name() const;
1244 
1245   // Verification
1246   void verify_on(outputStream* st);
1247 
1248   void oop_verify_on(oop obj, outputStream* st);
1249 
1250   // Logging
1251   void print_loading_log(LogLevel::type type, ClassLoaderData* loader_data, const ClassFileStream* cfs) const;
1252 };
1253 
1254 // for adding methods
1255 // UNSET_IDNUM return means no more ids available
1256 inline u2 InstanceKlass::next_method_idnum() {
1257   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1258     return ConstMethod::UNSET_IDNUM; // no more ids available
1259   } else {
1260     return _idnum_allocated_count++;
1261   }
1262 }
1263 
1264 
1265 /* JNIid class for jfieldIDs only */
1266 class JNIid: public CHeapObj&lt;mtClass&gt; {
1267   friend class VMStructs;
1268  private:
1269   Klass*             _holder;
1270   JNIid*             _next;
1271   int                _offset;
1272 #ifdef ASSERT
1273   bool               _is_static_field_id;
1274 #endif
1275 
1276  public:
1277   // Accessors
1278   Klass* holder() const           { return _holder; }
1279   int offset() const              { return _offset; }
1280   JNIid* next()                   { return _next; }
1281   // Constructor
1282   JNIid(Klass* holder, int offset, JNIid* next);
1283   // Identifier lookup
1284   JNIid* find(int offset);
1285 
1286   bool find_local_field(fieldDescriptor* fd) {
1287     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1288   }
1289 
1290   static void deallocate(JNIid* id);
1291   // Debugging
1292 #ifdef ASSERT
1293   bool is_static_field_id() const { return _is_static_field_id; }
1294   void set_is_static_field_id()   { _is_static_field_id = true; }
1295 #endif
1296   void verify(Klass* holder);
1297 };
1298 
1299 // An iterator that's used to access the inner classes indices in the
1300 // InstanceKlass::_inner_classes array.
1301 class InnerClassesIterator : public StackObj {
1302  private:
1303   Array&lt;jushort&gt;* _inner_classes;
1304   int _length;
1305   int _idx;
1306  public:
1307 
1308   InnerClassesIterator(instanceKlassHandle k) {
1309     _inner_classes = k-&gt;inner_classes();
1310     if (k-&gt;inner_classes() != NULL) {
1311       _length = _inner_classes-&gt;length();
1312       // The inner class array's length should be the multiple of
1313       // inner_class_next_offset if it only contains the InnerClasses
1314       // attribute data, or it should be
1315       // n*inner_class_next_offset+enclosing_method_attribute_size
1316       // if it also contains the EnclosingMethod data.
1317       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1318               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1319              "just checking");
1320       // Remove the enclosing_method portion if exists.
1321       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1322         _length -= InstanceKlass::enclosing_method_attribute_size;
1323       }
1324     } else {
1325       _length = 0;
1326     }
1327     _idx = 0;
1328   }
1329 
1330   int length() const {
1331     return _length;
1332   }
1333 
1334   void next() {
1335     _idx += InstanceKlass::inner_class_next_offset;
1336   }
1337 
1338   bool done() const {
1339     return (_idx &gt;= _length);
1340   }
1341 
1342   u2 inner_class_info_index() const {
1343     return _inner_classes-&gt;at(
1344                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1345   }
1346 
1347   void set_inner_class_info_index(u2 index) {
1348     _inner_classes-&gt;at_put(
1349                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1350   }
1351 
1352   u2 outer_class_info_index() const {
1353     return _inner_classes-&gt;at(
1354                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1355   }
1356 
1357   void set_outer_class_info_index(u2 index) {
1358     _inner_classes-&gt;at_put(
1359                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1360   }
1361 
1362   u2 inner_name_index() const {
1363     return _inner_classes-&gt;at(
1364                _idx + InstanceKlass::inner_class_inner_name_offset);
1365   }
1366 
1367   void set_inner_name_index(u2 index) {
1368     _inner_classes-&gt;at_put(
1369                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1370   }
1371 
1372   u2 inner_access_flags() const {
1373     return _inner_classes-&gt;at(
1374                _idx + InstanceKlass::inner_class_access_flags_offset);
1375   }
1376 };
1377 
1378 #endif // SHARE_VM_OOPS_INSTANCEKLASS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
